<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"makewe1.github.io",root:"/",scheme:"Muse",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!1,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!1},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!0,preload:!0},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="Common C++ Interview Questions C++ Basics Difference Between Pointers and References A pointer stores the address of an object. It is itself a variable(a named object) and has its own address, so you"><meta property="og:type" content="article"><meta property="og:title" content="C++ chapter"><meta property="og:url" content="https://makewe1.github.io/2025/08/28/Interview/C++/index.html"><meta property="og:site_name" content="Makeway"><meta property="og:description" content="Common C++ Interview Questions C++ Basics Difference Between Pointers and References A pointer stores the address of an object. It is itself a variable(a named object) and has its own address, so you"><meta property="og:locale" content="en_US"><meta property="article:published_time" content="2025-08-27T23:00:00.000Z"><meta property="article:modified_time" content="2026-01-05T01:32:07.242Z"><meta property="article:author" content="makewe1"><meta property="article:tag" content="C++"><meta property="article:tag" content="interview"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://makewe1.github.io/2025/08/28/Interview/C++/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"en"}</script><title>C++ chapter | Makeway</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer"><style>.github-emoji{position:relative;display:inline-block;width:1.2em;min-height:1.2em;overflow:hidden;vertical-align:top;color:transparent}.github-emoji>span{position:relative;z-index:10}.github-emoji .fancybox,.github-emoji img{margin:0!important;padding:0!important;border:none!important;outline:0!important;text-decoration:none!important;user-select:none!important;cursor:auto!important}.github-emoji img{height:1.2em!important;width:1.2em!important;position:absolute!important;left:50%!important;top:50%!important;transform:translate(-50%,-50%)!important;user-select:none!important;cursor:auto!important}.github-emoji-fallback{color:inherit}.github-emoji-fallback img{opacity:0!important}</style><link rel="alternate" href="/atom.xml" title="Makeway" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">Makeway</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en"><link itemprop="mainEntityOfPage" href="https://makewe1.github.io/2025/08/28/Interview/C++/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.gif"><meta itemprop="name" content="makewe1"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Makeway"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">C++ chapter</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2025-08-28 09:00:00" itemprop="dateCreated datePublished" datetime="2025-08-28T09:00:00+10:00">2025-08-28</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2026-01-05 12:32:07" itemprop="dateModified" datetime="2026-01-05T12:32:07+11:00">2026-01-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Interview/" itemprop="url" rel="index"><span itemprop="name">Interview</span></a></span></span></div></header><div class="post-body" itemprop="articleBody"><h1>Common C++ Interview Questions</h1><h2 id="C-Basics">C++ Basics</h2><h3 id="Difference-Between-Pointers-and-References">Difference Between Pointers and References</h3><p>A <strong>pointer</strong> stores the address of an object. It is itself a variable(a named object) and has its own address, so you can even have a pointer to a pointer.<br>A pointer can be changed – both the address it stores and the data at that address be modified.</p><p>A <strong>reference</strong> is simply an alias for a variable. Once bound, it cannot be changed to refer to another object, and it must be initialized when declared.</p><p>There is no such things as a “null reference”, but there can be a pointer to a null value.</p><p><strong>1. Definition and Declaration:</strong></p><p>A pointer is a variable whose value is the address of another variable.<br>When declaring a pointer, the <code>*</code> is used.</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">*ptr = &amp;x;</span><br></pre></td></tr></tbody></table></figure><p>A reference is an alias, created for an already existing variable. When declaring a reference, the <code>&amp;</code> is used.</p><p><strong>2. Usage and Operations:</strong></p><ul><li><strong>Pointer:</strong> By using the dereference operator <code>*</code>, you can access the value of the variable the pointer pointes to. You can also use the address-of operator <code>&amp;</code> to obtain the address of a variable.</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// get the value of the variable the the pointer points to</span></span><br><span class="line"><span class="type">int</span> address = &amp;x; <span class="comment">// obtain the address of variable x</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>Reference:</strong> A reference must be initialized when declared, and throughout its entire lifetime, it always refers to the same variable. You don’t need to use the dereference operator, because a reference itself is just another name for the variable.</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newValue = ref; <span class="comment">// get the reference value</span></span><br></pre></td></tr></tbody></table></figure><p><strong>3. Null Pointers and Null References:</strong></p><p>A pointer can be null(<code>nullptr</code>), meaning it does not point to any valid address.</p><p>A reference must be initialized at the time of declaration, and it cannot be changed to refer to a different object. Therefore, there is no concept of a null reference.</p><p><strong>4. Mutability:</strong></p><ul><li><p><strong>Pointer:</strong> A pointer can change what it points to, allowing it to refer to different memory addresses.</p></li><li><p><strong>Reference:</strong> Once a reference is initialized, it always refers to the same object and cannot be rebound.</p></li></ul><p><strong>5. Usage:</strong></p><ul><li><p><strong>Pointer:</strong> Commonly used for dynamic memory allocation, array operations, and function parameter passing.</p></li><li><p><strong>Reference:</strong> Commonly used for function parameter passing, operator overloading, and create aliases.</p></li></ul><h3 id="Data-Types">Data Types</h3><p><strong>Interger Types: <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code></strong></p><ul><li><code>short:</code> at least 16 bits</li><li><code>int:</code> at least as long as short</li><li><code>long:</code> at least 32 bits, and at least as long as <code>int</code></li><li><code>long long</code>: at least 64 bits, and at least as long as <code>long</code></li></ul><p>1 bytes is at least 8 bits. On modern system, a byte is always 8 bits.</p><h3 id="Keyword">Keyword</h3><h4 id="const-Keyword"><code>const</code> Keyword</h4><p><strong>Purpose of <code>const</code></strong><br>A variable or object qualified with <code>const</code> cannot be modified; it becomes read-only.<br>A <code>const</code> variable must be initialized at the point of definition.</p><h5 id="1-Constant-Pointer-a-k-a-“pointer-to-const”">1. Constant Pointer (a.k.a. “pointer to const”)</h5><p>A <em>constant pointer</em> means the pointer points to an object that cannot be modified through that pointer.<br>In other words, the pointer enforces immutable on the object it refers to.</p><p><strong>Key property</strong></p><ul><li>The pointer itself can still be reassigned to point to another object.</li><li>What is constant is the value being point to, not the pointer address.</li></ul><p><strong>Syntax Forms</strong></p><ol><li><code>const DadaType* ptr = variableName;</code><br>or equivalently:<br><code>DataType const* ptr = variableName;</code><br>-&gt; Pointer to an constant object(object cannot be modified through <code>ptr</code>).</li><li><code>DataType* const ptr = variableName;</code><br>-&gt; Constant pointer (the pointer itself cannot be reassigned, but the object it points to can be modified).</li></ol><p><strong>Example</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = &amp;temp;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = &amp;temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modification:</span></span><br><span class="line">*a = <span class="number">9</span>;     <span class="comment">// ❌ Error: cannot modify a read-only object through this pointer</span></span><br><span class="line">temp = <span class="number">9</span>;   <span class="comment">// ✅ Valid: the variable itself is not declared const</span></span><br></pre></td></tr></tbody></table></figure><h5 id="2-Const-Pointer-T-const">2. Const Pointer (<code>T* const</code>)</h5><p><strong>Definition</strong><br>A <strong>const pointer</strong> means that pointer’s address is fixed once initialized – you cannot make it point to another location afterwards.<br>What is constant here is the pointer itself, not the data it points to.</p><p><strong>Key Property</strong></p><ul><li>The pointer must be initialized at the time of definition.</li><li>After initialization, you cannot reassign it to another address.</li><li>The object being pointed to remains mutable(unless it was declared <code>const</code> separately).</li><li><strong>Syntax</strong></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataType* <span class="type">const</span> pointerName = &amp;varaible;</span><br></pre></td></tr></tbody></table></figure><p><strong>Example</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> temp1 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modification:</span></span><br><span class="line">p = &amp;temp1;  <span class="comment">// ❌ Error: p is a const pointer, cannot change its address</span></span><br><span class="line">*p = <span class="number">9</span>;      <span class="comment">// ✅ Valid: the pointee (temp) is still mutable</span></span><br></pre></td></tr></tbody></table></figure><h4 id="The-Role-of-the-static-Keyword">The Role of the <code>static</code> Keyword</h4><p>The <code>static</code> keyword is mainly used to control the lifecycle of variables and functions, their scope, and access permissions.</p><h5 id="1-Static-Variables">1. Static Variables</h5><ul><li>Variables declared with the <code>static</code> keyword inside a function are called static variables.</li><li>Static variables exist throughout the entire lifetime of the program and are not destroyed when leaving the function scope.</li><li>Static variables are initialized to zero by default (for basic data types).</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// static variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Count: "</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="2-Static-Functions">2. Static Functions</h5><ul><li>Functions declared with the <code>static</code> keyword inside a class are static member functions.</li><li>Static member functions belong to the class rather than to an instance, and can be called directly using the class name without creating an object.</li><li>Static member functions cannot directly access non-static member variables or non-static member functions.</li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Static function"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><h5 id="3-Static-Member-Variables">3. Static Member Variables</h5><ul><li><p>Member variables declared with the static keyword inside a class are static member variables.</p></li><li><p>All objects of the class share the same static member variable.</p></li><li><p>Static member variables must be defined once outside the class so memory can be allocated for them.</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;   <span class="comment">// declaration of static member variable</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition of static member variable</span></span><br><span class="line"><span class="type">int</span> ExampleClass::staticVar = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h5 id="4-Static-Member-Functions">4. Static Member Functions</h5><ul><li><p>Member functions declared with the static keyword inside a class are static member functions.</p></li><li><p>Static member functions cannot directly access non-static member variables or non-static member functions.</p></li><li><p>Static member functions can be called using the class name without creating an instance.</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTool</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{     <span class="comment">// static member function</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Call the static function using the class name</span></span><br><span class="line">    <span class="type">int</span> result = MathTool::<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;  <span class="comment">// Output: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><code>add</code> is a static member function</p><p>It belongs to the class, not to any object.</p><p>You DON’T need to write:</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MathTool tool;</span><br><span class="line">tool.<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);   <span class="comment">// ❌ Not required</span></span><br></pre></td></tr></tbody></table></figure><h5 id="5-Static-Local-Variables">5. Static Local Variables</h5><ul><li><p>Local variables declared with the static keyword inside a function are static local variables.</p></li><li><p>The lifetime of a static local variable lasts for the entire program execution, but it is only visible inside the function where it is declared.</p></li></ul><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> localVar = <span class="number">0</span>;   <span class="comment">// static local variable</span></span><br><span class="line">    localVar++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"LocalVar: "</span> &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="The-Role-of-the-const-Keyword">The Role of the <code>const</code> Keyword</h4><p>The <code>const</code> keyword is mainly used to specify that variables, pointers, references, and member functions cannot be modified.</p><h5 id="1-Constant-Variables">1. Constant Variables</h5><p>Declaring a constant variable makes its value unmodifiable.</p><h5 id="2-Pointers-and-References">2. Pointers and References</h5><p>Declaring a pointer to a constant means the value pointed to cannot be modified through the pointer.<br>Declaring a constant reference means the referenced value is constant and cannot be modified through the reference.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;constantValue;   <span class="comment">// pointer to constant</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = constantValue;    <span class="comment">// constant reference</span></span><br></pre></td></tr></tbody></table></figure><h5 id="3-Member-Functions">3. Member Functions</h5><p>Used to declare constant member functions, meaning the function will not modify member variables of the object (when those member variables are non-static).</p><h5 id="4-Constant-Objects">4. Constant Objects</h5><p>Declaring an object as constant makes all its member variables unmodifiable.</p><h5 id="5-Constant-Reference-Parameters">5. Constant Reference Parameters</h5><p>Declaring a function parameter as a constant reference means the function will not modify the passed-in argument.</p><h5 id="6-Constant-Pointer-Parameters">6. Constant Pointer Parameters</h5><p>Declaring a function parameter as a pointer to a constant means the function cannot modify the data pointed to by the pointer.</p><h4 id="Differences-Between-define-and-typedef">Differences Between <code>define</code> and <code>typedef</code></h4><h4 id="define">define</h4><ol><li>It is only a simple text substitution, with no type checking.</li><li>It takes effect during the preprocessing stage of compilation.</li><li>It can be used to prevent multiple inclusion of header files.</li><li>It does not allocate memory; the value is replaced every time it is used.</li></ol><h4 id="typedef">typedef</h4><ol><li>It has a corresponding data type, and type checking is performed.</li><li>It takes effect during compilation and runtime.</li><li>Space is allocated in static storage; during program execution, there is only one copy in memory.</li></ol><h4 id="Differences-Between-define-and-inline">Differences Between <code>define</code> and <code>inline</code></h4><h5 id="1-define">1. define</h5><p>A macro handled by the preprocessor. It is only a simple text substitution, has no type checking, and is unsafe.</p><h5 id="2-inline">2. inline</h5><p>Inline functions are compiled first and their function bodies are inserted directly at the call site, reducing stack operations, jumps, and returns. There is no overhead of a normal function call.</p><p>An inline function is a special type of function and will be type-checked.</p><p>A request to the compiler to inline the function — the compiler may reject this request.</p><h5 id="Restrictions-on-inline-in-C">Restrictions on inline in C++</h5><ol><li>Inline functions cannot contain any form of loop statements.</li><li>Inline functions cannot contain too many conditional statements.</li><li>The function body cannot be too large.</li><li>Inline functions must be defined before they are called.</li></ol><h4 id="Differences-Between-const-and-define">Differences Between <code>const</code> and <code>define</code></h4><p><code>const</code> is used to define constants; <code>define</code> is used to define macros, and macros can also be used to define constants. When both are used to define constants, their differences include:</p><ol><li><code>const</code> takes effect during the compilation stage; <code>define</code> takes effect during the preprocessing stage.</li><li>Constants defined with <code>const</code> are stored in memory in C and require extra memory space; constants defined with <code>define</code> are replaced directly during runtime and are not stored in memory.</li><li>Constants defined with <code>const</code> have types; constants defined with <code>define</code> do not have types. Therefore, <code>define</code> constants are not helpful for type checking.</li></ol><h4 id="Differences-Between-new-and-malloc">Differences Between <code>new</code> and <code>malloc</code></h4><ol><li>When <code>new</code> fails to allocate memory, it throws a <code>bad_alloc</code> exception and does not return NULL; when <code>malloc</code> fails, it returns NULL.</li><li>When using the <code>new</code> operator to allocate memory, you do not need to specify the size of the memory block; <code>malloc</code> requires you to explicitly specify the size of the required memory.</li><li><code>operator new</code> and <code>operator delete</code> can be overloaded, whereas <code>malloc</code>/<code>free</code> cannot be overloaded.</li><li><code>new</code>/<code>delete</code> will call the constructor/destructor of objects to complete object construction/destruction; <code>malloc</code> will not.</li><li><code>malloc</code> and <code>free</code> are standard functions of C/C++, while <code>new</code>/<code>delete</code> are C++ operators.</li><li>The <code>new</code> operator allocates dynamic memory from the free store (heap) for objects; <code>malloc</code> allocates dynamic memory from the heap as well.</li></ol><h5 id="Comparison-Table">Comparison Table</h5><table><thead><tr><th>Category</th><th>new/delete (C++)</th><th>malloc/free (C/C++)</th></tr></thead><tbody><tr><td>Nature</td><td>Operator</td><td>CRT library function</td></tr><tr><td>Memory Size</td><td>Automatically calculated</td><td>Manually specified</td></tr><tr><td>Type Safety</td><td>Yes (type-checked)</td><td>No (e.g., casting <code>malloc</code> result to different types won’t cause an error)</td></tr><tr><td>Relationship</td><td><code>new</code> is implemented using <code>malloc</code></td><td>Only allocates and frees memory</td></tr><tr><td>Other Features</td><td>Calls constructors/destructors</td><td>Does not call constructors/destructors</td></tr><tr><td></td><td>Throws <code>bad_alloc</code> on failure</td><td>Returns <code>NULL</code> on failure</td></tr><tr><td>Pointer Type</td><td>Returns a pointer of the exact type</td><td>Returns <code>void*</code>, requires type casting</td></tr></tbody></table><h4 id="constexpr-and-const">constexpr and const</h4><p>const represents read-only semantics, while constexpr represents constant-expression semantics.</p><p>constexpr can only define compile-time constants, whereas const can define compile-time constants as well as run-time constants.</p><p>If you mark a member function as constexpr, it is implicitly also marked as const.<br>If you mark a variable as constexpr, it is also const.<br>However, the reverse does not hold: a const variable or function is not necessarily constexpr.</p><h5 id="constexpr-Variables">constexpr Variables</h5><p>In complex systems, it can be difficult to determine whether an initializer is a constant expression.</p><p>You can declare a variable as <code>constexpr</code> and let the compiler verify whether its value is a constant expression.</p><p><strong>Must be initialized with a constant expression:</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> m = n + <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br></pre></td></tr></tbody></table></figure><p>If a pointer is declared using constexpr, constexpr applies only to the pointer itself, not to the object it points to.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>;     <span class="comment">// constant pointer (top-level const)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* q = <span class="literal">nullptr</span>;         <span class="comment">// pointer to const (low-level const)</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> r = <span class="literal">nullptr</span>;         <span class="comment">// constant pointer (top-level const)</span></span><br></pre></td></tr></tbody></table></figure><h5 id="constexpr-Functions">constexpr Functions</h5><p>A <code>constexpr</code> function is a function that can be used in a constant expression.</p><p>The return type and all parameter types must be literal types, and the function body must contain exactly one <code>return</code> statement.</p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_value</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">42</span>; }</span><br></pre></td></tr></tbody></table></figure><p>To allow expansion during compilation, a <code>constexpr</code> function is implicitly treated as an inline function.</p><p><code>constexpr</code> functions and inline functions can be defined multiple times in a program, and are typically defined in header files.</p><h3 id="Difference-Between-Constant-Pointer-and-Pointer-to-Constant">Difference Between Constant Pointer and Pointer to Constant</h3><ul><li><p>A constant pointer means the pointer itself is constant, but the content it points to can be changed.</p></li><li><p>A pointer to constant means the content pointed to is constant, but the pointer itself can be changed.</p></li><li><p>In a constant pointer, the keyword const appears after *.</p></li><li><p>In a pointer to constant, the keyword const appears before *.</p></li></ul><h3 id="Differences-Between-struct-and-class">Differences Between struct and class</h3><ul><li><p>Generally, <code>struct</code> is used to represent a group of related data, while <code>class</code> is used to represent an object that encapsulates both data and operations.<br>In practice, you can choose between <code>struct</code> and <code>class</code> based on actual needs.<br>If the purpose is only to organize some data without complex encapsulation or inheritance, <code>struct</code> may be more straightforward.<br>If encapsulation, inheritance, and other object-oriented features are required, <code>class</code> is usually preferred.</p></li><li><p>Members in a <code>struct</code> are <strong>public</strong> by default.<br>Members in a <code>class</code> are <strong>private</strong> by default.</p></li><li><p>When using inheritance, <code>struct</code> uses <strong>public inheritance</strong> by default,<br>while <code>class</code> uses <strong>private inheritance</strong> by default.</p></li><li><p>If a <code>struct</code> does not define any constructors, the compiler will generate a default no-argument constructor.<br>If a <code>class</code> does not define any constructors, the compiler will also generate a default no-argument constructor.</p></li></ul><h3 id="Difference-Between-Local-Variables-and-Static-Local-Variables">Difference Between Local Variables and Static Local Variables</h3><h4 id="1-Local-Variables">1. Local Variables</h4><p>A local variable is a variable defined inside a function or block.</p><h5 id="Characteristics">Characteristics</h5><ul><li><strong>Scope</strong>: Limited to the block or function where it is defined</li><li><strong>Lifetime</strong>: Exists only while the block is executing</li><li><strong>Storage</strong>: Typically allocated on the stack</li><li><strong>Initialization</strong>: Re-initialized every time the function is called</li><li><strong>Value retention</strong>: ❌ Does not retain value between calls</li></ul><h5 id="Example">Example</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// local variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Output if called multiple times:</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-Static-Local-Variables">2. Static Local Variables</h4><p>A static local variable is a local variable declared with the static keyword.</p><h5 id="Characteristics-2">Characteristics</h5><ul><li><strong>Scope</strong>: Limited to the function where it is defined</li><li><strong>Lifetime</strong>: Exists for the entire program execution</li><li><strong>Storage</strong>: Allocated in static storage area</li><li><strong>Initialization</strong>: Initialized only once</li><li><strong>Value retention</strong>: ✅ Retains value between function calls</li></ul><h5 id="Example-2">Example</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// static local variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>Output if called multiple times:</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure><h3 id="Upcasting-vs-Downcasting-C">Upcasting vs Downcasting (C++)</h3><h4 id="1️⃣-What-Is-Upcasting">1️⃣ What Is Upcasting?</h4><h5 id="Definition">Definition</h5><p>Upcasting is converting a derived-class pointer or reference<br>to a base-class pointer or reference.</p><p><strong>Derived → Base</strong><br>A <code>Derived</code> object looks like this in memory:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ Base part ][ Derived extra part ]</span><br></pre></td></tr></tbody></table></figure><h5 id="Example-3">Example</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base* b = &amp;d;   <span class="comment">// upcasting</span></span><br></pre></td></tr></tbody></table></figure><p>✔ Always safe<br>✔ Happens implicitly<br>✔ No cast required<br>✔ No runtime cost</p><h5 id="Why-Upcasting-Is-Safe">Why Upcasting Is Safe</h5><ul><li>A <code>Derived</code> object contains a <code>Base</code> subobject</li><li>The base part always exists</li><li>You are only <em>restricting access</em>, not assuming more</li></ul><h4 id="2️⃣-What-Is-Downcasting">2️⃣ What Is Downcasting?</h4><h5 id="Definition-2">Definition</h5><p>Downcasting is converting a base-class pointer or reference<br>to a derived-class pointer or reference.</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base → Derived</span><br></pre></td></tr></tbody></table></figure><h5 id="Example-Unsafe">Example (Unsafe)</h5><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// downcasting</span></span><br></pre></td></tr></tbody></table></figure><p>❌ Unsafe<br>❌ No runtime check<br>❌ Undefined behavior if object is not actually <code>Derived</code></p><h3 id="C-Explicit-Type-Casting">C++ Explicit Type Casting</h3><p><strong>Keywords:</strong> <code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code></p><hr><h4 id="1-static-cast">1. <code>static_cast</code></h4><p><code>static_cast</code> does not perform runtime type checking to guarantee the safety of the conversion.</p><ul><li><p><strong>Upcasting</strong><br>(converting a derived-class pointer or reference to a base-class representation)<br>is safe.</p></li><li><p><strong>Downcasting</strong><br>(converting a base-class pointer or reference to a derived-class representation)<br>is unsafe, because there is no dynamic type checking.</p></li></ul><p><strong>Usage</strong></p><ol><li>Used for conversions between basic data types, such as converting <code>int</code> to <code>char</code>.</li><li>Used to convert any expression to type <code>void</code>.</li></ol><h3 id="C-Virtual-Functions">C++ Virtual Functions</h3><p><strong>1. Introduction</strong></p><p>In C++, a virtual function is a member function of a class that is declared using the keyword <code>virtual</code> and is intended to be overridden in a derived class.</p><p>Virtual functions enable runtime polymorphism, which means the function that is executed is determined at runtime based on the actual type of the object, not the type of the pointer or reference used to access it.</p><p><strong>1. Motivation</strong></p><p>By default, C++ uses compile-time dispatch, where function calls are resolved based on the static type.</p><p>This behavior prevents correct polymorphic behavior when using base-class pointers or references.</p><p>Virtual functions solve this problem by deferring function selection until runtime.</p><p><strong>1. Basic Example</strong></p><p><strong>3.1 Without Virtual Function (Compile-Time Dispatch)</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">b-&gt;<span class="built_in">speak</span>();</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Base speaking</span><br></pre></td></tr></tbody></table></figure><p><strong>3.2 With Virtual Function (Runtime Dispatch)</strong></p><figure class="highlight cpp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">b-&gt;<span class="built_in">speak</span>();</span><br></pre></td></tr></tbody></table></figure><p>Output:</p><figure class="highlight text"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived speaking</span><br></pre></td></tr></tbody></table></figure></div><footer class="post-footer"><div class="post-tags"><a href="/tags/C/" rel="tag"># C++</a> <a href="/tags/interview/" rel="tag"># interview</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2025/08/26/AstraKV/Lec00-ProjectSetupAndEnvironment/" rel="prev" title="Lec00 – Project Overview and Environment Setup"><i class="fa fa-chevron-left"></i> Lec00 – Project Overview and Environment Setup</a></div><div class="post-nav-item"><a href="/2025/08/28/CMU%2015-213/15-213%20data-lab/" rel="next" title="CS:APP 15213 Data Lab Guide">CS:APP 15213 Data Lab Guide <i class="fa fa-chevron-right"></i></a></div></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link"><span class="nav-number">1.</span> <span class="nav-text">Common C++ Interview Questions</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#C-Basics"><span class="nav-number">1.1.</span> <span class="nav-text">C++ Basics</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Difference-Between-Pointers-and-References"><span class="nav-number">1.1.1.</span> <span class="nav-text">Difference Between Pointers and References</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Data-Types"><span class="nav-number">1.1.2.</span> <span class="nav-text">Data Types</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Keyword"><span class="nav-number">1.1.3.</span> <span class="nav-text">Keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#const-Keyword"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">const Keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Constant-Pointer-a-k-a-%E2%80%9Cpointer-to-const%E2%80%9D"><span class="nav-number">1.1.3.1.1.</span> <span class="nav-text">1. Constant Pointer (a.k.a. “pointer to const”)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Const-Pointer-T-const"><span class="nav-number">1.1.3.1.2.</span> <span class="nav-text">2. Const Pointer (T* const)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Role-of-the-static-Keyword"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">The Role of the static Keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Static-Variables"><span class="nav-number">1.1.3.2.1.</span> <span class="nav-text">1. Static Variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Static-Functions"><span class="nav-number">1.1.3.2.2.</span> <span class="nav-text">2. Static Functions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Static-Member-Variables"><span class="nav-number">1.1.3.2.3.</span> <span class="nav-text">3. Static Member Variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Static-Member-Functions"><span class="nav-number">1.1.3.2.4.</span> <span class="nav-text">4. Static Member Functions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Static-Local-Variables"><span class="nav-number">1.1.3.2.5.</span> <span class="nav-text">5. Static Local Variables</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#The-Role-of-the-const-Keyword"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">The Role of the const Keyword</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-Constant-Variables"><span class="nav-number">1.1.3.3.1.</span> <span class="nav-text">1. Constant Variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-Pointers-and-References"><span class="nav-number">1.1.3.3.2.</span> <span class="nav-text">2. Pointers and References</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-Member-Functions"><span class="nav-number">1.1.3.3.3.</span> <span class="nav-text">3. Member Functions</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-Constant-Objects"><span class="nav-number">1.1.3.3.4.</span> <span class="nav-text">4. Constant Objects</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-Constant-Reference-Parameters"><span class="nav-number">1.1.3.3.5.</span> <span class="nav-text">5. Constant Reference Parameters</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#6-Constant-Pointer-Parameters"><span class="nav-number">1.1.3.3.6.</span> <span class="nav-text">6. Constant Pointer Parameters</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Differences-Between-define-and-typedef"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">Differences Between define and typedef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#define"><span class="nav-number">1.1.3.5.</span> <span class="nav-text">define</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#typedef"><span class="nav-number">1.1.3.6.</span> <span class="nav-text">typedef</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Differences-Between-define-and-inline"><span class="nav-number">1.1.3.7.</span> <span class="nav-text">Differences Between define and inline</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-define"><span class="nav-number">1.1.3.7.1.</span> <span class="nav-text">1. define</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-inline"><span class="nav-number">1.1.3.7.2.</span> <span class="nav-text">2. inline</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Restrictions-on-inline-in-C"><span class="nav-number">1.1.3.7.3.</span> <span class="nav-text">Restrictions on inline in C++</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Differences-Between-const-and-define"><span class="nav-number">1.1.3.8.</span> <span class="nav-text">Differences Between const and define</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Differences-Between-new-and-malloc"><span class="nav-number">1.1.3.9.</span> <span class="nav-text">Differences Between new and malloc</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Comparison-Table"><span class="nav-number">1.1.3.9.1.</span> <span class="nav-text">Comparison Table</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#constexpr-and-const"><span class="nav-number">1.1.3.10.</span> <span class="nav-text">constexpr and const</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#constexpr-Variables"><span class="nav-number">1.1.3.10.1.</span> <span class="nav-text">constexpr Variables</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#constexpr-Functions"><span class="nav-number">1.1.3.10.2.</span> <span class="nav-text">constexpr Functions</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Difference-Between-Constant-Pointer-and-Pointer-to-Constant"><span class="nav-number">1.1.4.</span> <span class="nav-text">Difference Between Constant Pointer and Pointer to Constant</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Differences-Between-struct-and-class"><span class="nav-number">1.1.5.</span> <span class="nav-text">Differences Between struct and class</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Difference-Between-Local-Variables-and-Static-Local-Variables"><span class="nav-number">1.1.6.</span> <span class="nav-text">Difference Between Local Variables and Static Local Variables</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Local-Variables"><span class="nav-number">1.1.6.1.</span> <span class="nav-text">1. Local Variables</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Characteristics"><span class="nav-number">1.1.6.1.1.</span> <span class="nav-text">Characteristics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example"><span class="nav-number">1.1.6.1.2.</span> <span class="nav-text">Example</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Static-Local-Variables"><span class="nav-number">1.1.6.2.</span> <span class="nav-text">2. Static Local Variables</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Characteristics-2"><span class="nav-number">1.1.6.2.1.</span> <span class="nav-text">Characteristics</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example-2"><span class="nav-number">1.1.6.2.2.</span> <span class="nav-text">Example</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Upcasting-vs-Downcasting-C"><span class="nav-number">1.1.7.</span> <span class="nav-text">Upcasting vs Downcasting (C++)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1%EF%B8%8F%E2%83%A3-What-Is-Upcasting"><span class="nav-number">1.1.7.1.</span> <span class="nav-text">1️⃣ What Is Upcasting?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Definition"><span class="nav-number">1.1.7.1.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example-3"><span class="nav-number">1.1.7.1.2.</span> <span class="nav-text">Example</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Why-Upcasting-Is-Safe"><span class="nav-number">1.1.7.1.3.</span> <span class="nav-text">Why Upcasting Is Safe</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2%EF%B8%8F%E2%83%A3-What-Is-Downcasting"><span class="nav-number">1.1.7.2.</span> <span class="nav-text">2️⃣ What Is Downcasting?</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Definition-2"><span class="nav-number">1.1.7.2.1.</span> <span class="nav-text">Definition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Example-Unsafe"><span class="nav-number">1.1.7.2.2.</span> <span class="nav-text">Example (Unsafe)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Explicit-Type-Casting"><span class="nav-number">1.1.8.</span> <span class="nav-text">C++ Explicit Type Casting</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-static-cast"><span class="nav-number">1.1.8.1.</span> <span class="nav-text">1. static_cast</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#C-Virtual-Functions"><span class="nav-number">1.1.9.</span> <span class="nav-text">C++ Virtual Functions</span></a></li></ol></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><p class="site-author-name" itemprop="name">makewe1</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">9</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">6</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">8</span> <span class="site-state-item-name">tags</span></a></div></nav></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">makewe1</span></div><div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a></div></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z\d\-\.\+]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(t.test(e.href)||r.test(e.href))&&(e.href=a.dataset.original)})})</script><script>(r=>{r.imageLazyLoadSetting.processImages=t;var a=r.imageLazyLoadSetting.isSPA,o=r.imageLazyLoadSetting.preloadRatio||1,d=i();function i(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(t){(a||t)&&(d=i());for(var e,n=0;n<d.length;n++)0<=(e=(e=d[n]).getBoundingClientRect()).bottom&&0<=e.left&&e.top<=(r.innerHeight*o||document.documentElement.clientHeight*o)&&(()=>{var t,e,a,o,i=d[n];e=function(){d=d.filter(function(t){return i!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(i)},(t=i).dataset.loaded||(t.hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),e&&e()):(a=new Image,o=t.getAttribute("data-original"),a.onload=function(){t.src=o,t.removeAttribute("data-original"),t.setAttribute("data-loaded",!0),e&&e()},a.onerror=function(){t.removeAttribute("data-original"),t.setAttribute("data-loaded",!1),t.src=o},t.src!==o&&(a.src=o)))})()}function e(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",e),r.addEventListener("resize",e),r.addEventListener("orientationchange",e)})(this);</script></body></html>