<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Lec00 â€“ Project Overview and Environment Setup</title>
    <url>/2025/08/26/AstraKV/Lec00-ProjectSetupAndEnvironment/</url>
    <content><![CDATA[<h1>0. Project Overview</h1>
<h2 id="0-1-Project-Content">0.1 Project Content</h2>
<p>This project is a <strong>Key-Value (KV) storage engine</strong> built on the <strong>Log-Structured Merge-Tree (LSM Tree)</strong> architecture.<br>
It is about:</p>
<ol>
<li>The fundamental principles of KV storage engines</li>
<li>Core concepts of LSM Tree, a widely used storage architecture</li>
<li>Common practices in modern C++ programming</li>
</ol>
<h1>1. Operating System and Compiler Environment</h1>
<p>The project is developed using <strong>modern C++ (up to C++17 standard)</strong>.<br>
Any compiler that supports <strong>C++20 or later</strong> (such as <code>g++</code> or <code>clang++</code>) is fully compatible for building the system.</p>
<p>The development environment is based on <strong>Kali Linux</strong> running on WSL2. Since Kali and Ubuntu are both Debian-based distributions using the <code>apt</code> package manager, the installation instructions provided are directly applicable to Ubuntu or Debian systems as well.</p>
<h2 id="1-1-Compiler-Installation">1.1 Compiler Installation</h2>
<p>The project requires a modern C++ compiler. On Debian-based systems such as Ubuntu or Kali Linux, both GCC and G++ can be installed with the following commands:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y gcc</span><br><span class="line"><span class="built_in">sudo</span> apt install -y g++</span><br></pre></td></tr></tbody></table></figure>
<h2 id="1-2-Language-Server">1.2 Language Server</h2>
<p>To enhance the development experience, this project adopts <strong>clangd</strong> as the language server.<br>
Clangd is a lightweight C/C++ language server that integrates seamlessly with modern editors such as VS Code. It provides:</p>
<ul>
<li>Intelligent code completion</li>
<li>Go-to-definition and symbol navigation</li>
<li>Real-time diagnostics and error highlighting</li>
<li>Semantic syntax highlighting</li>
</ul>
<p>On Debian-based systems, clangd can be installed with:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install -y clangd</span><br></pre></td></tr></tbody></table></figure>
<h1>2. Project Management Tools</h1>
<h2 id="2-1-Xmake">2.1 Xmake</h2>
<h3 id="2-1-1-Installation">2.1.1 Installation</h3>
<p>This project uses <strong>Xmake</strong> as its primary project management tool.<br>
Xmake can be viewed as a combination of <strong>Make + CMake + vcpkg</strong>, providing functionality for:</p>
<ul>
<li>Project building</li>
<li>Dependency management</li>
<li>Execution and packaging</li>
</ul>
<p>Xmake can be installed with the following command:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl -fsSL https://xmake.io/shget.text | bash</span><br></pre></td></tr></tbody></table></figure>
<p>For more details, refer to the official documentation:<a href="https://xmake.io/#/getting_started">Xmake â€“ Getting Started</a></p>
<h1>3. VS Code Configuration</h1>
<h2 id="3-1-Code-Completion-and-Navigation">3.1 Code Completion and Navigation</h2>
<p>This project uses <strong>clangd</strong> as the language server.<br>
After installing clangd on your system, the next step is to enable it in VS Code.</p>
<p>To do so, install the <strong>clangd extension</strong> from the VS Code marketplace.<br>
This provides:</p>
<ul>
<li>Intelligent code completion</li>
<li>Go-to-definition and symbol navigation</li>
<li>Real-time diagnostics and error highlighting</li>
</ul>
<p><img src="clangd.png" alt="Xmake plugin in VS Code"></p>
<h2 id="3-2-Integrating-Xmake">3.2 Integrating Xmake</h2>
<p>In VSCode, the <strong>Xmake project management tool</strong> is supported. We can install the <strong>Xmake extension</strong>, which makes it more convenient to use Xmake for project management directly within VSCode.</p>
<p><img src="xmake.png" alt="Xmake plugin in VS Code"></p>
]]></content>
      <categories>
        <category>AstraKV</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>Lec01 â€“ Introduction to LSM Trees and Skip List Implementation</title>
    <url>/2025/09/14/AstraKV/Lec01%20%E2%80%93%20Introduction%20to%20LSM%20Trees%20and%20Skip%20List%20Implementation/</url>
    <content><![CDATA[<h1>1 LSM Tree Overall Architecture</h1>
<h2 id="1-1-Basic-Concepts">1.1 Basic Concepts</h2>
<h3 id="Log-Structured-Merge-Tree-LSM-tree">Log-Structured Merge Tree (LSM-tree)</h3>
<p>An <strong>LSM-tree</strong> is a way to store <strong>keyâ€“value data</strong> that makes <strong>writing very fast</strong> by:</p>
<ul>
<li><strong>First writing</strong> new data into memory (a small sorted table)</li>
<li><strong>Later saving</strong> it to disk as sorted files (<strong>SSTables</strong>)</li>
<li><strong>Merging</strong> old files in the background to keep them organized</li>
</ul>
<h4 id="Write-Ahead-Log-WAL">Write-Ahead Log (WAL)</h4>
<p><strong>WAL (Write-Ahead Log)</strong> is a <strong>log file</strong> used to protect data.</p>
<ul>
<li>Before changing real data, <strong>write the change to the log</strong></li>
<li>If the system crashes, you can <strong>replay the log to recover</strong></li>
</ul>
<h5 id="Reason">Reason</h5>
<p>Imagine your database is like a <strong>notebook</strong>:</p>
<ul>
<li>If the computer <strong>crashes mid-write</strong>, you could <strong>lose or corrupt data</strong></li>
</ul>
<h5 id="How-WAL-Helps">How WAL Helps</h5>
<ol>
<li><strong>First write</strong> the change to the <strong>WAL</strong> (like a safety diary(disk))</li>
<li><strong>Then apply</strong> the change to the real data (e.g. MemTable)</li>
<li>If a crash happens, on restart you can <strong>replay the WAL</strong> to recover lost changes</li>
</ol>
<p>This ensures <strong>data durability and crash recovery</strong></p>
<h4 id="LSM-Tree-Storage-Flow-with-WAL">LSM-Tree Storage Flow (with WAL)</h4>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">         (new write)</span><br><span class="line">              â”‚</span><br><span class="line">  +-------------------------+</span><br><span class="line">  |  Write-Ahead Log (WAL)  |  ğŸ“</span><br><span class="line">  |  - append-only on disk  |</span><br><span class="line">  +-------------------------+</span><br><span class="line">              â”‚</span><br><span class="line">   (also write to RAM at same time)</span><br><span class="line">              â”‚</span><br><span class="line">  +-------------------------+</span><br><span class="line">  |        MemTable         |  âš¡</span><br><span class="line">  |  - in-memory (skip list)|</span><br><span class="line">  |  - sorted               |</span><br><span class="line">  +-------------------------+</span><br><span class="line">              â”‚ (when full, flush)</span><br><span class="line">              â–¼</span><br><span class="line">  +-------------------------+</span><br><span class="line">  |   SSTable (Level 0)     |  ğŸ’¾</span><br><span class="line">  |  - on disk, immutable   |</span><br><span class="line">  |  - sorted inside        |</span><br><span class="line">  +-------------------------+</span><br><span class="line">              â”‚</span><br><span class="line">              â–¼</span><br><span class="line">  +---------------------------------+</span><br><span class="line">  |       Compaction process        |  âš™ï¸</span><br><span class="line">  |  - merges overlapping SSTables  |</span><br><span class="line">  |  - produces bigger sorted files |</span><br><span class="line">  +---------------------------------+</span><br><span class="line">              â”‚</span><br><span class="line">              â–¼</span><br><span class="line">+---------+       +---------+       +---------+</span><br><span class="line">|  L1     |  â†’ â†’ â†’ |  L2     |  â†’ â†’ â†’ |  L3...  |</span><br><span class="line">+---------+       +---------+       +---------+</span><br><span class="line">(on-disk, large, non-overlapping ranges)</span><br></pre></td></tr></tbody></table></figure>
<p><strong>step by step process</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Step 1: New writes go into WAL + MemTable</span><br><span class="line">----------------------------------------</span><br><span class="line">Client writes:</span><br><span class="line">   put("a", 1)</span><br><span class="line">   put("b", 2)</span><br><span class="line">   put("c", 3)</span><br><span class="line"></span><br><span class="line">WAL (disk):             MemTable (in memory, skip list):</span><br><span class="line"> [a,1], [b,2], [c,3]     aâ†’1, bâ†’2, câ†’3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 2: MemTable flush â†’ SSTable in L0</span><br><span class="line">--------------------------------------</span><br><span class="line">When MemTable is full, itâ€™s flushed to disk as SSTable_1:</span><br><span class="line"></span><br><span class="line">Level 0 (L0):</span><br><span class="line"> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line"> â”‚ SSTable_1     â”‚  --&gt; sorted: [a,1], [b,2], [c,3]</span><br><span class="line"> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 3: More writes come in</span><br><span class="line">----------------------------</span><br><span class="line">Client writes:</span><br><span class="line">   put("b", 20)   # update b</span><br><span class="line">   put("d", 4)</span><br><span class="line"></span><br><span class="line">WAL: append [b,20], [d,4]</span><br><span class="line">MemTable: bâ†’20, dâ†’4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 4: Flush new MemTable â†’ another L0 SSTable</span><br><span class="line">------------------------------------------------</span><br><span class="line">Level 0 (L0):</span><br><span class="line"> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line"> â”‚ SSTable_1     â”‚  --&gt; [a,1], [b,2], [c,3]</span><br><span class="line"> â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line"> â”‚ SSTable_2     â”‚  --&gt; [b,20], [d,4]</span><br><span class="line"> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line">âš  Keys overlap (both tables contain "b").</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 5: Compaction L0 â†’ L1</span><br><span class="line">---------------------------</span><br><span class="line">Pick overlapping SSTables (SSTable_1 + SSTable_2), merge-sort:</span><br><span class="line"></span><br><span class="line">Merged sequence:</span><br><span class="line">   [a,1], [b,2], [c,3], [b,20], [d,4]</span><br><span class="line"></span><br><span class="line">Keep latest values:</span><br><span class="line">   aâ†’1, bâ†’20, câ†’3, dâ†’4</span><br><span class="line"></span><br><span class="line">Result â†’ New SSTable in L1:</span><br><span class="line">Level 1 (L1):</span><br><span class="line"> â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line"> â”‚ SSTable_mergedâ”‚  --&gt; [a,1], [b,20], [c,3], [d,4]</span><br><span class="line"> â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"></span><br><span class="line">Old SSTable_1 and SSTable_2 are deleted after compaction.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Step 6: Reads after compaction</span><br><span class="line">-------------------------------</span><br><span class="line">- get("b") â†’ finds only "bâ†’20" (newest value).</span><br><span class="line">- Old value "bâ†’2" is discarded permanently.</span><br></pre></td></tr></tbody></table></figure>
<h4 id="How-Delete-Works-in-an-LSM-Tree">How Delete Works in an LSM-Tree</h4>
<p><strong>Put a Tombstone</strong></p>
<ul>
<li>A <strong>delete</strong> writes a special <strong>tombstone record</strong> (<code>key = &lt;tombstone&gt;</code>)</li>
<li>It <strong>does not remove</strong> old data immediately</li>
</ul>
<p><strong>Read Path</strong></p>
<ol>
<li><strong>Check MemTable first</strong></li>
<li>If a <strong>tombstone is found</strong>, ignore all older values of that key</li>
<li>Return <strong>â€œnot foundâ€</strong></li>
</ol>
<figure class="highlight sql"><table><tbody><tr><td class="code"><pre><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚      MemTable        â”‚</span><br><span class="line">â”‚  apple <span class="operator">=</span> <span class="operator">&lt;</span>tombstone<span class="operator">&gt;</span> â”‚   â† <span class="keyword">new</span> <span class="keyword">delete</span></span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line">           â–²</span><br><span class="line">           â”‚</span><br><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚      SSTable_1       â”‚</span><br><span class="line">â”‚   apple <span class="operator">=</span> red        â”‚   â† <span class="keyword">old</span> <span class="keyword">value</span></span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="B-Tree">B+ Tree</h3>
<p>A <strong>B+ Tree</strong> is a <strong>balanced search tree</strong> that stores <strong>sorted data</strong> and works <strong>efficiently on disk</strong>.<br>
It is widely used in databases (MySQL, PostgreSQL, SQLite) for <strong>fast searching and indexing</strong>.</p>
<h4 id="How-It-Works">How It Works</h4>
<ul>
<li>Each node stores <strong>many keys and child pointers</strong> (not just 2 like a binary tree)</li>
<li><strong>Internal nodes</strong>: store only keys to guide the search</li>
<li><strong>Leaf nodes</strong>: store the actual keyâ€“value pairs</li>
<li><strong>Leaf nodes are linked</strong> like a chain for fast range scans</li>
<li>The tree stays <strong>balanced</strong> â€” all leaf nodes are at the same depth</li>
</ul>
<h4 id="Structure">Structure</h4>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">                         [30 | 60]</span><br><span class="line">                     /               \</span><br><span class="line">         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">         â–¼                               â–¼</span><br><span class="line">   [10 | 20]                        [40 | 50 | 55]             â† internal nodes</span><br><span class="line">     /    |    \                       /    |     \</span><br><span class="line"> â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”             â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â” â”Œâ”€â”€â”€â”</span><br><span class="line">â–¼       â–¼      â–¼               â–¼       â–¼      â–¼</span><br><span class="line">[5 8 9] [12 18 19] [22 27 28]   [35 38 39] [42 47 49] [53 58 59]  â† leaf nodes</span><br><span class="line">â”‚         â”‚         â”‚             â”‚          â”‚           â”‚</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line">             (all leaf nodes linked left â†’ right)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Why-B-Tree-Is-Efficient-on-Disk">Why B+ Tree Is Efficient on Disk</h5>
<h5 id="ğŸ“¦-Fewer-Disk-Reads-High-Fan-Out">ğŸ“¦ Fewer Disk Reads (High Fan-Out)</h5>
<ul>
<li>Each node stores <strong>many keys</strong> (hundreds)</li>
<li>The tree becomes <strong>short and wide</strong></li>
<li>Searching needs only a <strong>few node accesses</strong></li>
<li>â†’ <strong>Fewer slow disk reads</strong></li>
</ul>
<h5 id="ğŸ“-Nodes-Match-Disk-Page-Size">ğŸ“ Nodes Match Disk Page Size</h5>
<ul>
<li>Each node is sized to <strong>fit exactly in one disk page</strong> (e.g. 4KB or 8KB)</li>
<li>Database reads a <strong>whole node in one I/O</strong></li>
<li>â†’ <strong>No wasted disk access</strong></li>
</ul>
<h5 id="ğŸ“š-Sequential-Leaf-Nodes-for-Range-Scans">ğŸ“š Sequential Leaf Nodes for Range Scans</h5>
<ul>
<li><strong>All leaf nodes are linked</strong> like a chain</li>
<li>Range queries (e.g. <code>BETWEEN 10 AND 100</code>) can scan leaves in order</li>
<li>â†’ Causes <strong>sequential disk reads</strong>, which are <strong>much faster</strong> than random reads</li>
</ul>
<hr>
<h3 id="B-Tree-vs-LSM-Tree-â€”-Overall-Comparison">B+ Tree vs LSM Tree â€” Overall Comparison</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>B+ Tree</th>
<th>LSM Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Main goal</strong></td>
<td>Fast reads</td>
<td>Fast writes</td>
</tr>
<tr>
<td><strong>Data layout</strong></td>
<td>One big balanced tree</td>
<td>Many sorted SSTable files in levels</td>
</tr>
<tr>
<td><strong>Where writes go</strong></td>
<td>Directly update leaf pages on disk</td>
<td>First to WAL + MemTable (RAM), then flushed</td>
</tr>
<tr>
<td><strong>Write pattern</strong></td>
<td>Random writes (in-place updates)</td>
<td>Sequential writes (append-only + compaction)</td>
</tr>
<tr>
<td><strong>Write speed</strong></td>
<td>âŒ Slower (many small random I/O)</td>
<td>âœ… Very fast (batched, sequential)</td>
</tr>
<tr>
<td><strong>Read path</strong></td>
<td>âœ… One binary search path through tree</td>
<td>âŒ Must search memtable + many SSTs across levels</td>
</tr>
<tr>
<td><strong>Read speed</strong></td>
<td>âœ… Very fast</td>
<td>âš ï¸ Slower (more disk seeks, merging needed)</td>
</tr>
<tr>
<td><strong>Range queries</strong></td>
<td>âœ… Very efficient (linked leaves)</td>
<td>âš ï¸ Slower (must merge multiple files)</td>
</tr>
<tr>
<td><strong>Compaction needed</strong></td>
<td>âŒ No</td>
<td>âœ… Yes (periodically merges old SSTs)</td>
</tr>
<tr>
<td><strong>Space usage</strong></td>
<td>âš ï¸ May get fragmented (page splits, deletes)</td>
<td>âœ… Compact (immutable files, merged)</td>
</tr>
<tr>
<td><strong>Memory use</strong></td>
<td>Lower (no memtable)</td>
<td>Higher (memtable + bloom filters)</td>
</tr>
<tr>
<td><strong>Typical use</strong></td>
<td>OLTP SQL DBs (MySQL, PostgreSQL, SQLite)</td>
<td>Key-value stores (RocksDB, LevelDB, Cassandra)</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="std-shared-ptr"><code>std::shared_ptr</code></h3>
<h4 id="Overview">Overview</h4>
<ul>
<li><strong><code>std::shared_ptr&lt;T&gt;</code></strong> is a smart pointer that <strong>shares ownership</strong> of a heap object.</li>
<li>It keeps a <strong>reference count</strong>; when the count drops to <strong>0</strong>, the object is <strong>deleted automatically</strong>.</li>
<li>Provides pointer-like access (<code>-&gt;</code>, <code>*</code>) with <strong>automatic lifetime management</strong>.</li>
</ul>
<h4 id="Ownership-Control-Block">Ownership &amp; Control Block</h4>
<ul>
<li>Each managed object has an associated <strong>control block</strong> storing:
<ul>
<li><strong>Strong count</strong>: number of <code>shared_ptr</code> owners.</li>
<li>(Optionally) a <strong>weak count</strong> for <code>std::weak_ptr</code>.</li>
<li>Custom <strong>deleter/allocator</strong> metadata.</li>
</ul>
</li>
<li>Creating/copying a <code>shared_ptr</code> <strong>increments</strong> the strong count; destroying/resetting <strong>decrements</strong> it.</li>
</ul>
<h4 id="Lifecycle-Step-by-Step">Lifecycle (Step-by-Step)</h4>
<ol>
<li><strong>Construction</strong>: Create with <code>std::make_shared&lt;T&gt;(...)</code> â†’ strong count becomes <strong>1</strong>.</li>
<li><strong>Copy</strong>: Assign/copy to another <code>shared_ptr</code> â†’ strong count <strong>+1</strong>.</li>
<li><strong>Move</strong>: Move-construct/assign transfers ownership â†’ source loses ownership, count unchanged.</li>
<li><strong>Scope Exit / Reset</strong>: A <code>shared_ptr</code> is destroyed or <code>reset()</code> is called â†’ strong count <strong>âˆ’1</strong>.</li>
<li><strong>Deletion</strong>: When strong count reaches <strong>0</strong>, the managed object is <strong>destroyed</strong>, and control block is released when weak count is also 0.</li>
</ol>
<h4 id="Reference-Count-Model">Reference Count Model</h4>
<ul>
<li>
<p><strong>Transitions</strong>:</p>
<ul>
<li><strong>Copy</strong>:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c(t+1) = c(t) + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
<li><strong>Destroy / Reset</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>âˆ’</mo><mn>14</mn></mrow><annotation encoding="application/x-tex">c(t+1) = c(t) - 14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">14</span></span></span></span></li>
<li><strong>Move</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">c(t+1) = c(t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span></span></span></span> (ownership transferred, count unchanged)</li>
</ul>
</li>
<li>
<p><strong>Deletion condition</strong>:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>if&nbsp;</mtext><mi>c</mi><mo stretchy="false">(</mo><mi>t</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn><mtext>â€…â€Š</mtext><mo>â‡’</mo><mtext>â€…â€Š</mtext><mtext>delete&nbsp;object</mtext></mrow><annotation encoding="application/x-tex">
  \text{if } c(t) = 0 \;\Rightarrow\; \text{delete object}
  </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">if&nbsp;</span></span><span class="mord mathnormal">c</span><span class="mopen">(</span><span class="mord mathnormal">t</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â‡’</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">delete&nbsp;object</span></span></span></span></span></span>
</li>
</ul>
<h4 id="Example">Example</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// for std::shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Create a shared_ptr to an int (value = 42)</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">"p1 created. use_count = "</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="comment">// Output: 1 (only p1 owns the object)</span></span><br><span class="line"></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Copy p1 to p2 â†’ both point to the same object</span></span><br><span class="line">        shared_ptr&lt;<span class="type">int</span>&gt; p2 = p1;</span><br><span class="line">        cout &lt;&lt; <span class="string">"p2 created from p1. use_count = "</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// Output: 2 (p1 and p2 both own it)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Copy p2 to p3 â†’ all three share the same object</span></span><br><span class="line">        shared_ptr&lt;<span class="type">int</span>&gt; p3 = p2;</span><br><span class="line">        cout &lt;&lt; <span class="string">"p3 created from p2. use_count = "</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        <span class="comment">// Output: 3 (p1, p2, p3 all own it)</span></span><br><span class="line">    } <span class="comment">// p2 and p3 are destroyed here â†’ count goes down to 1</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"p2 and p3 gone. use_count = "</span> &lt;&lt; p<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Manually release p1 â†’ count goes to 0 â†’ object is deleted</span></span><br><span class="line">    p<span class="number">1.</span><span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">"p1 reset. object deleted now.\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Circular-Reference-with-std-shared-ptr">Circular Reference with <code>std::shared_ptr</code></h4>
<ul>
<li><code>shared_ptr</code> uses reference counting.</li>
<li>If two objects hold <code>shared_ptr</code> to each other, their counts never reach 0.</li>
<li>They never get deleted â†’ memory leak.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> { shared_ptr&lt;Node&gt; other; };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">make_shared</span>&lt;Node&gt;(); <span class="comment">// a:1</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">make_shared</span>&lt;Node&gt;(); <span class="comment">// b:1</span></span><br><span class="line">    a-&gt;other = b; <span class="comment">// b:2</span></span><br><span class="line">    b-&gt;other = a; <span class="comment">// a:2</span></span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">" "</span> &lt;&lt; b.<span class="built_in">use_count</span>(); <span class="comment">// 2 2</span></span><br><span class="line">} <span class="comment">// a,b go out of scope but not deleted (cycle)</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="std-weak-ptr"><code>std::weak_ptr</code></h3>
<h4 id="Overview-2">Overview</h4>
<ul>
<li><code>weak_ptr</code> <strong>does not own</strong> the object; it just <strong>observes</strong> one managed by <code>shared_ptr</code>.</li>
<li>It <strong>does not increase</strong> reference count, so it <strong>breaks cycles</strong>.</li>
<li>When all <code>shared_ptr</code> owners are gone, the object is deleted and any <code>weak_ptr</code> becomes <strong>expired</strong>.</li>
</ul>
<h4 id="Example-2">Example</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> { weak_ptr&lt;Node&gt; other; };</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="built_in">make_shared</span>&lt;Node&gt;(); <span class="comment">// A owners: 1</span></span><br><span class="line">    <span class="keyword">auto</span> b = <span class="built_in">make_shared</span>&lt;Node&gt;(); <span class="comment">// B owners: 1</span></span><br><span class="line"></span><br><span class="line">    a-&gt;other = b; <span class="comment">// weak watch of B (owners unchanged: B still 1)</span></span><br><span class="line">    b-&gt;other = a; <span class="comment">// weak watch of A (owners unchanged: A still 1)</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">"A owners = "</span> &lt;&lt; a.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">"B owners = "</span> &lt;&lt; b.<span class="built_in">use_count</span>() &lt;&lt; <span class="string">"\n"</span>; <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// When a and b go out of scope, both counts drop to 0 â†’ deleted.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">a-&gt;next = b;  <span class="comment">// next is weak_ptr</span></span><br><span class="line"></span><br><span class="line">           <span class="built_in">b</span> (shared_ptr)          a-&gt;<span class="built_in">next</span> (weak_ptr)</span><br><span class="line">                â”‚                         â”‚</span><br><span class="line">                â–¼                         â–¼</span><br><span class="line">        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">        â”‚            control block                 â”‚</span><br><span class="line">        â”‚  - Node address â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚</span><br><span class="line">        â”‚  - <span class="function">strong <span class="title">count</span> <span class="params">(shared_ptrs)</span>   â”‚        |</span></span><br><span class="line"><span class="function">        â”‚  - weak <span class="title">count</span> <span class="params">(weak_ptrs)</span>       â”‚        â”‚</span></span><br><span class="line"><span class="function">        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></span><br><span class="line"><span class="function">                                 â–¼</span></span><br><span class="line"><span class="function">                           Node object</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="Accessing-Through-weak-ptr">Accessing Through <code>weak_ptr</code></h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> p = a-&gt;other.<span class="built_in">lock</span>()) {</span><br><span class="line">    <span class="comment">// p is a shared_ptr&lt;Node&gt;; object still alive</span></span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">// expired: the object was deleted</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Summary">Summary</h4>
<table>
<thead>
<tr>
<th>Pointer Type</th>
<th>Increases Ref Count</th>
<th>Keeps Object Alive</th>
<th>Can Expire</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shared_ptr</code></td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td><code>weak_ptr</code></td>
<td>No</td>
<td>No</td>
<td>Yes</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="References">References</h3>
<ul>
<li>A <strong>reference</strong> is an <strong>alias (second name)</strong> for an existing variable.</li>
<li>It does <strong>not create a copy</strong>.</li>
<li>Changing the reference changes the <strong>original variable</strong>.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">type&amp; refName = existingVariable;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Example-3">Example</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span>&amp; r = x; <span class="comment">// r is a reference to x</span></span><br><span class="line"></span><br><span class="line">    r = <span class="number">20</span>;     <span class="comment">// changes x</span></span><br><span class="line">    cout &lt;&lt; x;  <span class="comment">// prints 20</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Key-Points">Key Points</h4>
<ul>
<li>Must be <strong>initialized</strong> when declared.</li>
<li>Cannot be changed to refer to another variable.</li>
<li>Behaves exactly like the original variable.</li>
</ul>
<h4 id="Summary-2">Summary</h4>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Reference (<code>&amp;</code>)</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Creates new object?</code></td>
<td>No</td>
</tr>
<tr>
<td><code>Copies data?   </code></td>
<td>No</td>
</tr>
<tr>
<td><code>Can be reseated?  </code></td>
<td>No</td>
</tr>
<tr>
<td><code>Needs initialization </code></td>
<td>Yes</td>
</tr>
<tr>
<td><code>Syntax   </code></td>
<td><code>type&amp; name = var;</code></td>
</tr>
</tbody>
</table>
<h3 id="Constructor-in-C-SkipListNode-Example">Constructor in C++ (SkipListNode Example)</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SkipListNode</span> {</span><br><span class="line">    std::string key;</span><br><span class="line">    std::string value;</span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;SkipListNode&gt;&gt; forward;</span><br><span class="line">    std::vector&lt;std::weak_ptr&lt;SkipListNode&gt;&gt; backward;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SkipListNode</span>(<span class="type">const</span> std::string&amp; k, <span class="type">const</span> std::string&amp; v, <span class="type">int</span> level)</span><br><span class="line">        : <span class="built_in">key</span>(k), <span class="built_in">value</span>(v), forward(level, <span class="literal">nullptr</span>),</span><br><span class="line">          <span class="built_in">backward</span>(level, std::<span class="built_in">weak_ptr</span>&lt;SkipListNode&gt;()) {}</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>key(k)</code> â†’ initializes <strong>key</strong> with parameter <code>k</code>.</li>
<li><code>value(v)</code> â†’ initializes <strong>value</strong> with parameter <code>v</code>.</li>
<li><code>forward(level, nullptr)</code> â†’ creates a <strong>vector of size <code>level</code></strong>, each element a <code>nullptr</code> <code>shared_ptr</code>.</li>
<li><code>backward(level, std::weak_ptr&lt;SkipListNode&gt;())</code> â†’ creates a <strong>vector of size <code>level</code></strong>, each element an <strong>empty</strong> <code>weak_ptr</code>.</li>
<li>The <strong>constructor body <code>{}</code> is empty</strong> because all fields are initialized in the <strong>initializer list</strong>.</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>v</mi><mo separator="true">,</mo><mi mathvariant="normal">â„“</mi><mo stretchy="false">)</mo><mtext>â€…â€Š</mtext><mo>â†¦</mo><mtext>â€…â€Š</mtext><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>k</mi><mo separator="true">,</mo><mtext>â€…â€Š</mtext><mi>v</mi><mo separator="true">,</mo><mtext>â€…â€Š</mtext><mo stretchy="false">[</mo><mtext>nullptr</mtext><msup><mo stretchy="false">]</mo><mi mathvariant="normal">â„“</mi></msup><mo separator="true">,</mo><mtext>â€…â€Š</mtext><mo stretchy="false">[</mo><mtext>empty</mtext><msup><mo stretchy="false">]</mo><mi mathvariant="normal">â„“</mi></msup><mo fence="false" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">
(k, v, \ell) \;\mapsto\; \big( k,\; v,\; [\text{nullptr}]^\ell,\; [\text{empty}]^\ell \big)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">â„“</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†¦</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2491em;vertical-align:-0.35em;"></span><span class="mord"><span class="delimsizing size1">(</span></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord text"><span class="mord">nullptr</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">â„“</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">[</span><span class="mord text"><span class="mord">empty</span></span><span class="mclose"><span class="mclose">]</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">â„“</span></span></span></span></span></span></span></span><span class="mord"><span class="delimsizing size1">)</span></span></span></span></span></span>
<hr>
<h3 id="Skip-List-Class-Definition">Skip List Class Definition</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Skip List class</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SkipList</span> {</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::shared_ptr&lt;SkipListNode&gt; head; <span class="comment">// head node of the skip list</span></span><br><span class="line">    <span class="type">int</span> max_level;                      <span class="comment">// maximum level of the skip list</span></span><br><span class="line">    <span class="type">int</span> current_level;                  <span class="comment">// current level of the skip list</span></span><br><span class="line">    <span class="type">size_t</span> size_bytes;                  <span class="comment">// memory usage in bytes</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SkipList</span>(<span class="type">int</span> max_lvl = <span class="number">16</span>);         <span class="comment">// constructor, default max level is 16</span></span><br><span class="line">    <span class="comment">// ... other methods will be defined later</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li>Defines a <strong>class</strong> named <code>SkipList</code>.</li>
<li>This class represents the <strong>entire skip list structure</strong>, not just a single node.</li>
</ul>
<h4 id="Private-Members">Private Members</h4>
<ul>
<li><strong>Only accessible inside the class</strong>, hidden from external code.</li>
<li>Used to store the <strong>internal state</strong> of the skip list.</li>
</ul>
<table>
<thead>
<tr>
<th>Member</th>
<th>Type</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>head</code></td>
<td><code>std::shared_ptr&lt;SkipListNode&gt;</code></td>
<td>The <strong>head (sentinel) node</strong> of the skip list, entry point for all levels</td>
</tr>
<tr>
<td><code>max_level</code></td>
<td><code>int</code></td>
<td>The <strong>maximum number of levels</strong> the skip list can have</td>
</tr>
<tr>
<td><code>current_level</code></td>
<td><code>int</code></td>
<td>The <strong>highest level currently used</strong> in the skip list</td>
</tr>
<tr>
<td><code>size_bytes</code></td>
<td><code>size_t</code></td>
<td>Tracks <strong>memory usage</strong> (optional bookkeeping)</td>
</tr>
</tbody>
</table>
<h4 id="Public-Members">Public Members</h4>
<ul>
<li><strong>Accessible from outside</strong> the class.</li>
<li>Provides the <strong>interface</strong> for creating and using the skip list.</li>
</ul>
<table>
<thead>
<tr>
<th>Member</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>SkipList(int max_lvl = 16)</code></td>
<td><strong>Constructor</strong> to initialize the skip list. Defaults to <code>max_lvl = 16</code>.</td>
</tr>
</tbody>
</table>
<h4 id="Why-We-Do-This">Why We Do This</h4>
<ul>
<li>
<p><strong>Encapsulation:</strong><br>
Internal details (nodes, size, levels) are kept <code>private</code> so they canâ€™t be modified incorrectly from outside.</p>
</li>
<li>
<p><strong>Clear interface:</strong><br>
Only safe, controlled operations will be exposed through <code>public</code> methods later (insert, search, delete).</p>
</li>
<li>
<p><strong>Head node:</strong><br>
The head sentinel simplifies logic â€” every level starts from this single node.</p>
</li>
<li>
<p><strong>max/current levels:</strong><br>
Allow the skip list to work like a <strong>multi-level linked list</strong> and support <strong>fast search <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>â¡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></strong>.</p>
</li>
</ul>
<hr>
<h1>Skip List Impementaion</h1>
<h2 id="Core-Operation-Implementation">Core Operation Implementation</h2>
<h3 id="Insert-or-update-function">Insert or update function</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Insert or update a key-value pair in the skip list</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SkipList::put</span><span class="params">(<span class="type">const</span> std:: string &amp;key, <span class="type">const</span> std::string &amp;value)</span> </span>{</span><br><span class="line">    <span class="comment">// Create an update vector to track the last node visited at each level</span></span><br><span class="line">    std::vector&lt;std::shared_ptr&lt;SkipListNode&gt;&gt; <span class="built_in">update</span>(max_level, <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">auto</span> current = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Traverse from top level down to level 0 to find insertion point</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = current_level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">        <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;key &lt; key) {</span><br><span class="line">            current = current-&gt;forward[i]; <span class="comment">// Move forward if next key is still less than target key</span></span><br><span class="line">        }</span><br><span class="line">        update[i] = current; <span class="comment">// Remember the last node before the insertion point at this level</span></span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now current points to the next node at level 0</span></span><br><span class="line">    current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If key already exists, update its value and adjust size tracking</span></span><br><span class="line">    <span class="keyword">if</span> (current &amp;&amp; current-&gt;key == key) {</span><br><span class="line">        size_bytes += value.<span class="built_in">size</span>() - current-&gt;value.<span class="built_in">size</span>();</span><br><span class="line">        current-&gt;value = value;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Otherwise, create a new node with random level</span></span><br><span class="line">    <span class="type">int</span> new_level = <span class="built_in">random_level</span>();</span><br><span class="line">    <span class="keyword">if</span> (new_level &gt; current_level) {</span><br><span class="line">        <span class="comment">// If new node's level is greater than current lest level,</span></span><br><span class="line">        <span class="comment">// initialize the update pointers at these higher levels to head</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = current_level; i &lt; new_level; ++i) {</span><br><span class="line">            update[i] = head;</span><br><span class="line">        }</span><br><span class="line">        current_level = new_level; <span class="comment">// Update the current highest level</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the new node and add its size</span></span><br><span class="line">    <span class="keyword">auto</span> new_node = std::<span class="built_in">make_shared</span>&lt;SkipListNde&gt;(key, value, new_level);</span><br><span class="line">    size_bytes += key.<span class="built_in">size</span>() + value.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Insert the new node by updateing forward pointers at each level</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; new_level; ++i) {</span><br><span class="line">        new_node-&gt;forward[i] = updata[i]-&gt;forward[i];</span><br><span class="line">        update[i]-&gt;forward[i] = new_node;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set backward pointers</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; new_level; ++i) {</span><br><span class="line">        <span class="keyword">if</span> (new_node-&gt;forward[i]) {</span><br><span class="line">            new_node-&gt;forward[i]-&gt;<span class="built_in">set_backward</span>(i, new_node);</span><br><span class="line">        }</span><br><span class="line">        new_node-&gt;<span class="built_in">set_backward</span>(i, update[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="Retrieve-function">Retrieve function</h3>
<h4 id="Code">Code</h4>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Retrieve the value associated with a key in the skip list</span></span><br><span class="line"><span class="function">std::optional&lt;std::string&gt; <span class="title">SkipList::get</span><span class="params">(<span class="type">const</span> std::string &amp;key)</span> </span>{</span><br><span class="line">  <span class="comment">// Optional shared (read) lock for thread-safe access.</span></span><br><span class="line">  <span class="comment">// std::shared_lock&lt;std::shared_mutex&gt; slock(rw_mutex);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> current = head; <span class="comment">// Start from the sentinel head at the topmost level</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Traverse from the current highset level down to level 0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = current_level - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) {</span><br><span class="line">    <span class="comment">// Move forward at level i as long as the next node exists</span></span><br><span class="line">    <span class="comment">// and its key is less than the target key</span></span><br><span class="line">    <span class="keyword">while</span> (current-&gt;forward[i] &amp;&amp; current-&gt;forward[i]-&gt;key &lt; key) {</span><br><span class="line">      current = current-&gt;forward[i];</span><br><span class="line">    }</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step to the candidate node at level 0 (the exact-postion check happens</span></span><br><span class="line">  <span class="comment">// here)</span></span><br><span class="line">  current = current-&gt;forward[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If the candidate matches the key, return the stored value</span></span><br><span class="line">  <span class="keyword">if</span> (current &amp;&amp; current-&gt;key == key) {</span><br><span class="line">    <span class="keyword">return</span> current-&gt;value;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise, the key does not exist in the list</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="How-to-saerch">How to saerch</h4>
<ul>
<li>Start from the <strong>top level</strong> (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>=</mo><mi>c</mi><mi>u</mi><mi>r</mi><mi>r</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi mathvariant="normal">_</mi><mi>l</mi><mi>e</mi><mi>v</mi><mi>e</mi><mi>l</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i = current\_level - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">u</span><span class="mord mathnormal">rre</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>)</li>
<li>At each level <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>:
<ul>
<li>Move <strong>forward</strong> while <code>next.key &lt; target.key</code></li>
<li>If blocked, <strong>go down</strong> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">i - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7429em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></li>
</ul>
</li>
<li>This makes <strong>big jumps at high levels</strong> and <strong>small steps at low levels</strong>:</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>top</mtext><mtext>â€…â€Š</mtext><mo>â‡’</mo><mtext>â€…â€Š</mtext><mtext>bottom:&nbsp;big</mtext><mo>â†’</mo><mtext>medium</mtext><mo>â†’</mo><mtext>small&nbsp;steps</mtext></mrow><annotation encoding="application/x-tex">\text{top} \;\Rightarrow\; \text{bottom: big} \to \text{medium} \to \text{small steps}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8095em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">top</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â‡’</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">bottom:&nbsp;big</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">medium</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">small&nbsp;steps</span></span></span></span></span></span>
<h4 id="How-key-Works-in-get-const-std-string-key">How <code>&amp;key</code> Works in <code>get(const std::string &amp;key)</code></h4>
<ul>
<li><code>const std::string &amp;key</code> means:
<ul>
<li><strong><code>key</code> is a reference (alias) to the input string</strong> passed into the function.</li>
<li>It does <strong>not copy</strong> the input.</li>
<li>It is just a <strong>different name</strong> for the same string while inside the function.</li>
</ul>
</li>
</ul>
<p>Let the caller give an input string <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span>:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>x</mi><mo>=</mo><mtext>"mkw02020202"</mtext></mrow><annotation encoding="application/x-tex">x = \text{"mkw02020202"}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">"mkw02020202"</span></span></span></span></span></span>
<p>Call:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">get</span>(x);</span><br></pre></td></tr></tbody></table></figure>
<p>Inside the function:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="normal">&amp;</mi><mi>k</mi><mi>e</mi><mi>y</mi><mtext>â€…â€Š</mtext><mo>â‡’</mo><mtext>â€…â€Š</mtext><mtext>reference&nbsp;to&nbsp;</mtext><mi>x</mi></mrow><annotation encoding="application/x-tex">\&amp;key \;\Rightarrow\; \text{reference to } x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">&amp;</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â‡’</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">reference&nbsp;to&nbsp;</span></span><span class="mord mathnormal">x</span></span></span></span></span>
<p>So:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>k</mi><mi>e</mi><mi>y</mi><mo>â‰¡</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">key \equiv x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.03588em;">ey</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â‰¡</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></span>
<hr>
<h3 id="SkipList-Iterator">SkipList Iterator</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SkipListIterator</span> : <span class="keyword">public</span> BaseIterator { <span class="comment">// it defines a class called SkipListIterator that inherits publicly from a base class called BaseIterator</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- private</span></span><br><span class="line"><span class="comment">// Many other readers are allowed at the same time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Any writer must wait until all readers finish</span></span><br><span class="line"><span class="comment">// ---</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Pointer to the current skip list node</span></span><br><span class="line">  std::shared_ptr&lt;SkipListNode&gt; current;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Shared read lock (may be adjusted later for concurrency control)</span></span><br><span class="line">  std::shared_ptr&lt;std::shared_lock&lt;std::shared_mutex&gt;&gt; lock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructor: initialize iterator with a starting node</span></span><br><span class="line">  <span class="built_in">SkipListIterator</span>(std::shared_ptr&lt;SkipListNode&gt; node);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Pre-increment: move to the next node and return reference</span></span><br><span class="line">  BaseIterator &amp;<span class="keyword">operator</span>++() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Equality check: true if both iterators point to the same node</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BaseIterator &amp;other) <span class="type">const</span> <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Inequality check: true if iterators point to different nodes</span></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BaseIterator &amp;other) <span class="type">const</span> <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Dereference operator: return key-value pair of the current node</span></span><br><span class="line">  value_type <span class="keyword">operator</span>*() <span class="type">const</span> <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Identify this iterator as SkipList type</span></span><br><span class="line">  <span class="function">IteratorType <span class="title">get_type</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if iterator is valid (not null and usable)</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if iterator has reached the end (nullptr)</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_end</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the transaction ID associated with the current node</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">get_tranc_id</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the key of the current node</span></span><br><span class="line">  <span class="function">std::string <span class="title">get_key</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Get the value of the current node</span></span><br><span class="line">  <span class="function">std::string <span class="title">get_value</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">};</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<h4 id="Code-Explain">Code Explain</h4>
<p><strong>How the <code>:</code> works in a constructor</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">SkipListIterator::<span class="built_in">SkipListIterator</span>(std::shared_ptr&lt;SkipListNode&gt; node)</span><br><span class="line">    : <span class="built_in">current</span>(node) {}</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><code>:</code> introduces the <strong>member initializer list</strong></li>
<li><code>: current(node)</code> means:<br>
â€œWhen constructing this object, create the member <code>current</code> and initialize it with <code>node</code>.â€</li>
<li>This happens <strong>before</strong> the <code>{ }</code> constructor body runs</li>
</ul>
<p><strong>In simple words:</strong></p>
<ul>
<li><code>:</code> introduces the <strong>member initializer list</strong></li>
<li><code>: current(node)</code> means:<br>
â€œWhen constructing this object, create the member <code>current</code> and initialize it with <code>node</code>.â€</li>
<li>This happens <strong>before</strong> the <code>{ }</code> constructor body runs</li>
</ul>
<p><strong>In simple words:</strong></p>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>:</mo><mtext>&nbsp;</mtext><mo>â†’</mo><mtext>&nbsp;initialize&nbsp;member(s)</mtext></mrow><annotation encoding="application/x-tex">:\ \to\ \text{initialize member(s)}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mrel">:</span><span class="mspace">&nbsp;</span></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">â†’</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord">initialize&nbsp;member(s)</span></span></span></span></span>
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><mtext>&nbsp;</mtext><mo stretchy="false">}</mo><mtext>&nbsp;</mtext><mo>â†’</mo><mtext>&nbsp;then&nbsp;run&nbsp;the&nbsp;constructor&nbsp;body</mtext></mrow><annotation encoding="application/x-tex">\{\ \}\ \to\ \text{then run the constructor body}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mspace">&nbsp;</span><span class="mclose">}</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">â†’</span><span class="mspace">&nbsp;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">then&nbsp;run&nbsp;the&nbsp;constructor&nbsp;body</span></span></span></span></span>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;std::shared_lock&lt;std::shared_mutex&gt;&gt; lock;</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Mutex">Mutex</h4>
<p>A <strong>mutex</strong> (short for <strong>mutual exclusion</strong>) is a <strong>lock object</strong> that ensures <strong>only one thread can access a shared resource at a time</strong>.</p>
<p><strong>Why We Need a Mutex</strong></p>
<ul>
<li>When multiple <strong>threads</strong> run at the same time, they may try to <strong>read and write the same data simultaneously</strong>.</li>
<li>This can cause <strong>race conditions</strong> â€” leading to <strong>corrupted or unpredictable results</strong>.</li>
<li>A <strong>mutex</strong> prevents this by <strong>blocking other threads</strong> until the <strong>current thread finishes using the data</strong>.</li>
</ul>
<p><strong>How It Works</strong></p>
<ol>
<li>
<p><code>mtx.lock()</code> â€” Try to take (lock) the mutex</p>
<ul>
<li>If itâ€™s <strong>free</strong>, this thread <strong>acquires it</strong>.</li>
<li>If another thread already has it, this thread <strong>waits (blocks)</strong>.</li>
</ul>
</li>
<li>
<p><code>mtx.unlock()</code> â€” <strong>Release the mutex</strong> so other waiting threads can acquire it.<br>
Only one thread at a time can hold the mutex.</p>
</li>
</ol>
<h4 id="shared-mutex">shared_mutex</h4>
<p>A <strong>shared mutex</strong> is a special kind of mutex that allows <strong>two modes of locking</strong>:</p>
<ul>
<li><strong>Shared (read) mode</strong> â€” many threads can hold it <strong>at the same time</strong> to <strong>read</strong> shared data safely.</li>
<li><strong>Exclusive (write) mode</strong> â€” only <strong>one thread</strong> can hold it, and it <strong>blocks all readers and writers</strong> while it <strong>writes</strong>.</li>
</ul>
<p>Because of this behavior, itâ€™s also called a <strong>readâ€“write lock</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">std::shared_lock&lt;std::shared_mutex&gt;</span><br></pre></td></tr></tbody></table></figure>
<p>A <strong>lock object</strong> that uses <code>std::shared_mutex</code> in <strong>shared (read) mode</strong>:</p>
<ul>
<li>When created, it calls <code>mutex.lock_shared()</code></li>
<li>When destroyed, it calls <code>mutex.unlock_shared()</code></li>
<li>Multiple <code>shared_lock</code>s can exist at the same time â†’ <strong>many readers are allowed</strong></li>
</ul>
<p><strong>Shared Lock Behavior</strong></p>
<p>A <strong>shared lock</strong> is specifically made to:</p>
<ul>
<li><strong>Allow multiple threads to read at the same time</strong></li>
<li>While <strong>blocking any writers until all readers are done</strong></li>
</ul>
]]></content>
      <categories>
        <category>AstraKV</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Note 1</title>
    <url>/2025/09/16/C++/Note_1/</url>
    <content><![CDATA[<h2 id="Miscellaneous">Miscellaneous</h2>
<h4 id="1">1</h4>
<p>When you want to share constants (like <code>SKIPLIST_P</code>) across your project, you normally put them in a header file inside your include/ directory. For example:</p>
<figure class="highlight makefile"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>/</span><br><span class="line"> â””â”€â”€ consts.h</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p>And inside consts.h you can write:</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SKIPLIST_P 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Old style (C / macros)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SKIPLIST_P 0.5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Modern C++ style (preferred)</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">double</span> SKIPLIST_P = <span class="number">0.5</span>;</span><br></pre></td></tr></tbody></table></figure>
<p><code>#define</code> is a preprocessor macro. Before compilation, the preprocessor literally replaces every <code>SKIPLIST_P</code> with <code>0.5</code>. Thatâ€™s why it doesnâ€™t need a type.</p>
<h4 id="Scope-Resolution-Operator">Scope Resolution Operator (<code>::</code>)</h4>
<p>The <code>::</code> operator lets you <strong>explicitly tell the compiler which scope to use</strong>.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">scope_name::identifier</span><br></pre></td></tr></tbody></table></figure>
<p>A <strong>scope</strong> is a region of code where a name (variable, function, class, etc.) is visible.<br>
For example:</p>
<ul>
<li>The <strong>global scope</strong> is outside all functions/classes.</li>
<li>Each <strong>function</strong> has its own local scope.</li>
<li>Each <strong>class</strong> has its own member scope.</li>
<li>Each <strong>namespace</strong> has its own scope.</li>
</ul>
<h2 id="Structure-of-a-Lambda-with-std-function">Structure of a Lambda with <code>std::function</code></h2>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line">function&lt;ReturnType(ParamType1, ParamType2, ...)&gt; name =</span><br><span class="line">    [&amp;](ParamType1 p1, ParamType2 p2, ...) -&gt; ReturnType {</span><br><span class="line">        <span class="comment">// function body</span></span><br><span class="line">    };</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Meaning-of-Each-Part">Meaning of Each Part</h3>
<table>
<thead>
<tr>
<th>Part</th>
<th>What it means</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>function&lt;ReturnType(ParamTypes...)&gt;</code></td>
<td>Declares a variable that can hold <strong>any callable</strong> with those parameter and return types</td>
</tr>
<tr>
<td><code>name</code></td>
<td>The variable name for your lambda â€” you can call it like a normal function later</td>
</tr>
<tr>
<td><code>&amp;</code> in <code>[&amp;]</code></td>
<td><strong>Capture all outer variables by reference</strong>, so the lambda can access them</td>
</tr>
<tr>
<td><code>(ParamType p1, ParamType p2, ...)</code></td>
<td>The <strong>parameter list</strong> with variable names</td>
</tr>
<tr>
<td><code>-&gt; ReturnType</code></td>
<td>The <strong>return type</strong> of the lambda (needed when doing recursion)</td>
</tr>
<tr>
<td><code>{ ... }</code></td>
<td>The <strong>function body</strong> â€” code that runs when you call the lambda</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="Understanding-C-Constructors">Understanding C++ Constructors</h2>
<p>A constructor is a special function that runs when we create an object.<br>
It has <strong>three main parts</strong>:</p>
<h3 id="Parameters-the-input">Parameters (the input)</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">MyClass</span>(<span class="type">int</span> value, <span class="type">bool</span> f)</span><br></pre></td></tr></tbody></table></figure>
<p>These are the inputs we pass when creating the object.</p>
<p>Example:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>, <span class="literal">true</span>)</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>Here, value = 42 and f = true.</p>
<h3 id="Member-initializer-list-after-the">Member initializer list after the :</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">: <span class="built_in">x</span>(value), <span class="built_in">flag</span>(f)</span><br></pre></td></tr></tbody></table></figure>
<p>This part <strong>initializes</strong> the member variables directly with the inputs.<br>
It is more efficient than assignment inside <code>{}</code> because the members are built with these values immediately.</p>
<p>Think of it like:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>member</mtext><mo>=</mo><mtext>input</mtext></mrow><annotation encoding="application/x-tex"> \text{member} = \text{input} </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord">member</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8623em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">input</span></span></span></span></span></span>
<h3 id="Constructor-body">Constructor body { }</h3>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">{</span><br><span class="line"><span class="comment">// extra code runs here after members are initialized</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>This is where you put extra logic, loops, or setup code.<br>
It runs after the member variables have been set.</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Note</tag>
      </tags>
  </entry>
  <entry>
    <title>Lec02 â€“ MemTable</title>
    <url>/2025/09/22/AstraKV/Lec02-MemTable/</url>
    <content><![CDATA[<h1>1 MemTable Implementation</h1>
<h2 id="1-1-Principle-Analysis">1.1 Principle Analysis</h2>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">                 â”‚    Client     â”‚</span><br><span class="line">                 â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line">                         â”‚</span><br><span class="line">               r1. Write to active SkipList</span><br><span class="line">                         â”‚</span><br><span class="line">                         â–¼</span><br><span class="line">               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">               â”‚      MemTable     â”‚</span><br><span class="line">               â”‚                   â”‚</span><br><span class="line">               â”‚   Active SkipList â”‚  &lt;â”€â”€â”€ current writes go here</span><br><span class="line">               â”‚                   â”‚</span><br><span class="line">               â”‚   Frozen SkipList â”‚  &lt;â”€â”€â”€ once full, turned read-only</span><br><span class="line">               â”‚   Frozen SkipList â”‚</span><br><span class="line">               â”‚   Frozen SkipList â”‚</span><br><span class="line">               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line">                  â–²             â–²</span><br><span class="line">                  â”‚             â”‚</span><br><span class="line">r1. Query active SkipList      r2. Query frozen SkipList</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Explanation">Explanation</h3>
<p><strong>Active SkipList</strong></p>
<ul>
<li>
<p>The in-memory structure currently accepting writes.</p>
</li>
<li>
<p>All new inserts/updates go here.</p>
</li>
<li>
<p>Reads first check this list.</p>
</li>
</ul>
<p><strong>Frozen SkipLists</strong></p>
<ul>
<li>
<p>When the active SkipList fills up, it is frozen (read-only).</p>
</li>
<li>
<p>Eventually, these frozen skip lists are flushed to disk as SSTables.</p>
</li>
<li>
<p>Reads must also check these until they are flushed.</p>
</li>
</ul>
<p><strong>Client flow</strong></p>
<ul>
<li>
<p>r1 (Write) â†’ client writes into the active skip list.</p>
</li>
<li>
<p>r1 (Read) â†’ reads first check active skip list.</p>
</li>
<li>
<p>r2 (Read) â†’ if not found, reads also check frozen skip lists.</p>
</li>
</ul>
]]></content>
      <categories>
        <category>AstraKV</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title>CS:APP 15213 Data Lab Guide</title>
    <url>/2025/08/28/CMU%2015-213/15-213%20data-lab/</url>
    <content><![CDATA[<h2 id="logicalNeg">logicalNeg</h2>
<h3 id="Step-1-â€”-Define-the-goal">Step 1 â€” Define the goal</h3>
<p>We need a function that acts like logical <code>!x</code> without using the <code>!</code> operator:</p>
<ul>
<li>If <code>x == 0</code>, return <strong>1</strong></li>
<li>If <code>x != 0</code>, return <strong>0</strong></li>
</ul>
<h3 id="Step-2-â€”-Find-the-unique-bit-feature-of-0">Step 2 â€” Find the unique bit feature of 0</h3>
<p>We notice that for <code>x == 0</code>, both <code>x</code> and <code>-x</code> are <code>0</code>, so their sign bit is <code>0</code>.<br>
For any <code>x != 0</code>, either <code>x</code> or <code>-x</code> is negative, so at least one sign bit is <code>1</code>.</p>
<p>This means <code>(x | -x)</code> will have sign bit = <code>0</code> only when <code>x == 0</code>,<br>
and sign bit = <code>1</code> for any <code>x != 0</code>.</p>
<p>Since <code>-x</code> must be expressed using allowed operators,<br>
we write it as <code>~x + 1</code> (twoâ€™s complement negation).</p>
<h3 id="Step-3-â€”-Turn-the-sign-bit-into-0-1">Step 3 â€” Turn the sign bit into 0/1</h3>
<p>We have two methods:</p>
<h4 id="Method-1-â€”-Use-1-and-1">Method 1 â€” Use <code>&amp; 1</code> and <code>^ 1</code></h4>
<p><code>(((~x + 1) | x) &gt;&gt; 31) &amp; 1</code> gives <strong>1</strong> when <code>x != 0</code>, <strong>0</strong> when <code>x == 0</code>.<br>
Flip to match logical NOT:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">((((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) &amp; <span class="number">1</span>) ^ <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="Method-2-â€”-Add-1-Cleaner-Way">Method 2 â€” Add 1 (Cleaner Way)</h4>
<p>When we do an arithmetic right shift by 31 bits:</p>
<ul>
<li>For any nonzero <code>x</code>, <code>(((~x + 1) | x) &gt;&gt; 31)</code> gives <strong>-1</strong> (all bits = 1).</li>
<li>For <code>x == 0</code>, the result is <strong>0</strong>.</li>
</ul>
<p>So if we simply add 1:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">(((~x + <span class="number">1</span>) | x) &gt;&gt; <span class="number">31</span>) + <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="howManyBits">howManyBits</h2>
<p>The goal is to return the minimum number of bits required to represent an integer <code>x</code> in <strong>twoâ€™s complement</strong>.</p>
<p>Examples:</p>
<ul>
<li><code>howManyBits(12) = 5</code></li>
<li><code>howManyBits(298) = 10</code></li>
<li><code>howManyBits(-5) = 4</code></li>
<li><code>howManyBits(0) = 1</code></li>
<li><code>howManyBits(-1) = 1</code></li>
<li><code>howManyBits(0x80000000) = 32</code></li>
</ul>
<h3 id="Intuition">Intuition</h3>
<p>Twoâ€™s complement numbers have <strong>runs of identical leading bits</strong>:</p>
<ul>
<li>Non-negative values start with leading <code>0</code>s.</li>
<li>Negative values start with leading <code>1</code>s.</li>
</ul>
<p>To get the <em>minimal</em> width, we:</p>
<ol>
<li>Keep <strong>one sign bit</strong> (a single leading <code>0</code> or <code>1</code>), and</li>
<li>Count up to the <strong>first bit that differs</strong> from the sign bit.</li>
</ol>
<p>So the problem reduces to: <strong>find the index of the most significant â€œmeaningfulâ€ bit</strong>, then add 1 for the sign.</p>
<h3 id="Normalizing-negative-and-positive-numbers">Normalizing negative and positive numbers</h3>
<p>If we could make both cases look like â€œnon-negative with leading zeros,â€ then the job is just â€œfind the highest <code>1</code> bit.â€ We can!</p>
<p>We get the sign:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>; <span class="comment">// 0x00000000 if x &gt;= 0, 0xFFFFFFFF if x &lt; 0</span></span><br></pre></td></tr></tbody></table></figure>
<p>Then:</p>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line">x ^ sign</span><br></pre></td></tr></tbody></table></figure>
<p>acts like:</p>
<ul>
<li>If <code>x &gt;= 0</code>: <code>sign = 0</code>, so <code>x ^ 0 = x</code> (unchanged).</li>
<li>If <code>x &lt; 0</code>:  <code>sign = -1</code> (all ones), so <code>x ^ (-1) = ~x</code> (bitwise NOT).</li>
</ul>
<p><strong>Effect:</strong> negatives get flipped to remove their leading 1s; positives stay as they are. After this, we can uniformly â€œsearch for the highest 1.â€</p>
<h3 id="Binary-search-on-bit-ranges">Binary search on bit ranges</h3>
<p>We check chunks 16, 8, 4, 2, 1 bits to find where the top <code>1</code> lives. Each step says:</p>
<ul>
<li>â€œIs there any <code>1</code> in the upper half?â€</li>
<li>If yes, we advance the count and shift <code>x</code> down into that half.</li>
<li>If not, we keep searching the lower half.</li>
</ul>
<p>We use <code>!!(expr)</code> to normalize to <code>0</code> or <code>1</code>, and then shift that <code>1</code> by a power-of-two to add <code>16</code>, <code>8</code>, <code>4</code>, <code>2</code>, or <code>1</code> to the answer without branches.</p>
<h3 id="Always-add-one-sign-bit">Always add one sign bit</h3>
<p>After counting the highest <code>1</code> bit, we always add <strong>one more bit</strong> for the sign.</p>
<p>This covers all cases:</p>
<ul>
<li>For <code>x = 0</code>, no bits are set, so <code>min_bits = 0</code>, plus sign â†’ <code>1</code> bit.</li>
<li>For <code>x = -1</code>, all bits are <code>1</code>, but flipping gives <code>0</code>, so <code>min_bits = 0</code>, plus sign â†’ <code>1</code> bit.</li>
<li>For <code>x = 1</code>, highest bit = 0, so <code>min_bits = 1</code>, plus sign â†’ <code>2</code> bits.</li>
</ul>
<h3 id="Final-implementation">Final implementation</h3>
<figure class="highlight c"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">howManyBits</span><span class="params">(<span class="type">int</span> x)</span></span><br><span class="line">{</span><br><span class="line">  <span class="type">int</span> sign = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line">  <span class="type">int</span> min_bits = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Normalize: positives unchanged, negatives flipped</span></span><br><span class="line">  x = x ^ sign;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find index of highest 1 via binary search on bit ranges</span></span><br><span class="line">  tmp = !!(x &gt;&gt; <span class="number">16</span>) &lt;&lt; <span class="number">4</span>; min_bits += tmp; x &gt;&gt;= tmp;</span><br><span class="line">  tmp = !!(x &gt;&gt; <span class="number">8</span>)  &lt;&lt; <span class="number">3</span>; min_bits += tmp; x &gt;&gt;= tmp;</span><br><span class="line">  tmp = !!(x &gt;&gt; <span class="number">4</span>)  &lt;&lt; <span class="number">2</span>; min_bits += tmp; x &gt;&gt;= tmp;</span><br><span class="line">  tmp = !!(x &gt;&gt; <span class="number">2</span>)  &lt;&lt; <span class="number">1</span>; min_bits += tmp; x &gt;&gt;= tmp;</span><br><span class="line">  tmp = !!(x &gt;&gt; <span class="number">1</span>);       min_bits += tmp; x &gt;&gt;= tmp;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Add the last bit (if x is 1 now)</span></span><br><span class="line">  min_bits += x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Plus one sign bit to cover all cases</span></span><br><span class="line">  min_bits += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_bits;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="floatPower2">floatPower2</h2>
<h3 id="32-bit-float-Bit-Layout-Diagram">32-bit float Bit Layout Diagram</h3>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><br><span class="line">â”‚ Sign  â”‚      Exponent      |               Fraction                |</span><br><span class="line">â”‚ (1bit)â”‚      (8 bits)      |              (23 bits)                |</span><br><span class="line">â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><br><span class="line">â”‚   0   â”‚ 0 0 0 0 0 0 0 0    | 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 |</span><br><span class="line">â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><br><span class="line"> bit 31         bits 30â€“23                         bits 22â€“0</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>
<p><strong>example</strong></p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">0 10000001 01100000000000000000000</span><br><span class="line">â”‚ â”‚        â””â”€ mantissa (1.011...)</span><br><span class="line">â”‚ â”” exponent (129 = 2 after bias)</span><br><span class="line">â”” sign</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Special Case: Denormal / Subnormal Numbers</strong></p>
<p><strong>Condition:</strong></p>
<ul>
<li><code>exponent = 0</code></li>
<li>and <code>fraction â‰  0</code></li>
</ul>
<p><strong>Then:</strong></p>
<ul>
<li>There is <strong>no implicit leading <code>1</code></strong> before the fraction bits</li>
<li>The exponent is treated as <code>1 - 127 = -126</code></li>
</ul>
<p><strong>Value Formula:</strong></p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mo>âˆ’</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mtext>sign</mtext></msup><mo>Ã—</mo><mn>0.</mn><mtext>fraction&nbsp;bits</mtext><mo>Ã—</mo><msup><mn>2</mn><mrow><mo>âˆ’</mo><mn>126</mn></mrow></msup></mrow><annotation encoding="application/x-tex">
(-1)^{\text{sign}} \times 0.\text{fraction bits} \times 2^{-126}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.1305em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">âˆ’</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8805em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">sign</span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord">0.</span><span class="mord text"><span class="mord">fraction&nbsp;bits</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8641em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">âˆ’</span><span class="mord mtight">126</span></span></span></span></span></span></span></span></span></span></span></span></span>
<h3 id="Code">Code</h3>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// Return the bit-level equivalent of 2.0^x as a float (single-precision)</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="title">floatPower2</span><span class="params">(<span class="type">int</span> x)</span> </span>{</span><br><span class="line">    <span class="comment">// Too small: smaller than the smallest denorm (2^-149)</span></span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">-149</span>) <span class="keyword">return</span> <span class="number">0u</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Too large: larger than the largest finite power (2^127)</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">127</span>) <span class="keyword">return</span> <span class="number">0x7f800000u</span>; <span class="comment">// +INF</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Normalized range: -126 &lt;= x &lt;= 127</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">-126</span>) {</span><br><span class="line">        <span class="type">unsigned</span> exp = (<span class="type">unsigned</span>)(x + <span class="number">127</span>); <span class="comment">// bias = 127</span></span><br><span class="line">        <span class="keyword">return</span> exp &lt;&lt; <span class="number">23</span>;                   <span class="comment">// sign=0, frac=0</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Denormalized range: -149 &lt;= x &lt;= -127</span></span><br><span class="line">    <span class="comment">// value = frac * 2^-149  =&gt;  frac = 2^(x+149)</span></span><br><span class="line">    <span class="type">unsigned</span> frac = <span class="number">1u</span> &lt;&lt; (x + <span class="number">149</span>);</span><br><span class="line">    <span class="keyword">return</span> frac; <span class="comment">// sign=0, exp=0</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>]]></content>
      <categories>
        <category>CMU 15-213</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Computer Science</tag>
      </tags>
  </entry>
  <entry>
    <title>Dynamic Programming Notes</title>
    <url>/2025/08/29/DataStructures-Algorithms/Dynamic-Programming-Notes/</url>
    <content><![CDATA[<h2 id="DP-Dependencies">DP Dependencies</h2>
<p>In <strong>Dynamic Programming (DP)</strong>, each state often depends on results from <strong>smaller subproblems</strong>.<br>
The order you compute states matters because <strong>dependencies must be ready first</strong>.</p>
<h3 id="Key-Takeaways">Key Takeaways</h3>
<ul>
<li>
<p>Always compute dependencies first.</p>
</li>
<li>
<p>DP fails if you process states in the wrong order.</p>
</li>
</ul>
<h3 id="Loop-Order-Examples">Loop Order Examples</h3>
<p><strong>Original sequence (wrong, dependencies not ready):</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):           <span class="comment"># i = 0 â†’ n-1 (increasing)</span></span><br><span class="line">    dp[i][i] = <span class="literal">True</span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):    <span class="comment"># j &gt; i</span></span><br><span class="line">        <span class="keyword">if</span> j - i == <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = (s[i] == s[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]   <span class="comment"># dp[i+1][j-1] may not be ready!</span></span><br><span class="line">        <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">            ans += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>Reversed sequence (correct, dependencies ready):</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># i = n-1 â†’ 0 (decreasing)</span></span><br><span class="line">    dp[i][i] = <span class="literal">True</span></span><br><span class="line">    ans += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, n):    <span class="comment"># j &gt; i</span></span><br><span class="line">        <span class="keyword">if</span> j - i == <span class="number">1</span>:</span><br><span class="line">            dp[i][j] = (s[i] == s[j])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][j] = (s[i] == s[j]) <span class="keyword">and</span> dp[i+<span class="number">1</span>][j-<span class="number">1</span>]   <span class="comment"># dp[i+1][j-1] always ready now</span></span><br><span class="line">        <span class="keyword">if</span> dp[i][j]:</span><br><span class="line">            ans += <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Classic-DP-procedure">Classic DP procedure</h2>
<p><strong>State â†’ Base cases â†’ Recurrence â†’ Fill table â†’ Answer</strong></p>
<h3 id="Example">Example</h3>
<blockquote>
<p><strong>Coin Change II â€” Standard 2D DP Approach</strong></p>
<p><strong>Given</strong> an integer <code>amount</code> and an integer array <code>coins</code> representing coin denominations,<br>
<strong>return</strong> the number of <strong>combinations</strong> that make up <code>amount</code>.<br>
You may use each coin <strong>unlimited</strong> times; <strong>order doesnâ€™t matter</strong> (i.e., <code>{1,2}</code> is the same as <code>{2,1}</code>).</p>
</blockquote>
<h4 id="1-Define-the-DP-State">1. Define the DP State</h4>
<p><code>dp[i][j]</code>= number of ways to make sum j using the first i coins (coins[0â€¦i-1])</p>
<ul>
<li><code>i = 0..n</code> (n = number of coins) â†’ rows</li>
<li><code>j = 0..amount</code> â†’ columns</li>
</ul>
<h4 id="Base-Cases">Base Cases</h4>
<ul>
<li><code>dp[i][0] = 1</code> for all <code>i</code> â†’ one way to make amount 0 (choose nothing)</li>
<li><code>dp[0][j] = 0</code> for all <code>j &gt; 0</code> â†’ canâ€™t make positive sum with 0 coins</li>
</ul>
<h4 id="Recurrence-Unbounded-Knapsack-Combinations">Recurrence (Unbounded Knapsack: Combinations)</h4>
<p>For each coin <code>i (1-indexed)</code> and sum <code>j</code>:</p>
<ul>
<li><strong>Donâ€™t use</strong> coin i â†’ <code>dp[i-1][j]</code></li>
<li><strong>Use</strong> coin i at least once (if <code>j &gt;= coins[i-1]</code>) â†’ <code>dp[i][j - coins[i-1]]</code></li>
</ul>
<h4 id="Fill-Order">Fill Order</h4>
<ul>
<li>Outer loop: coins <code>i = 1..n</code></li>
<li>Inner loop: amount <code>j = 0..amount</code></li>
<li>Build row by row, left to right.</li>
</ul>
<h4 id="Answer">Answer</h4>
<p>Final answer = <code>dp[n][amount]</code></p>
<h4 id="Reference-Implementation-Python">Reference Implementation (Python)</h4>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">change</span>(<span class="params">self, amount, coins</span>):</span><br><span class="line">        n = <span class="built_in">len</span>(coins)</span><br><span class="line">        dp = [[<span class="number">0</span>] * (amount + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Base: 1 way to make 0 (choose nothing)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>):</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">            coin = coins[i - <span class="number">1</span>]</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(amount + <span class="number">1</span>):</span><br><span class="line">                <span class="comment"># don't use coin i</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j]</span><br><span class="line">                <span class="comment"># use coin i (unbounded)</span></span><br><span class="line">                <span class="keyword">if</span> j &gt;= coin:</span><br><span class="line">                    dp[i][j] += dp[i][j - coin]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][amount]</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Knapsack-Problem">Knapsack Problem</h2>
<h3 id="0-1-Knapsack-Problem">0/1 Knapsack Problem</h3>
<p>You have:</p>
<ul>
<li>
<p><strong><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></strong> items, each with:</p>
<ul>
<li><strong>Weight</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>w</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">w_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li><strong>Value</strong> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>v</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">v_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
<li>
<p>A <strong>knapsack</strong> with a weight capacity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi></mrow><annotation encoding="application/x-tex">W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></p>
</li>
</ul>
<p><strong>Goal</strong><br>
Choose a subset of items such that:</p>
<ul>
<li>The total weight <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>â‰¤</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">\le W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7719em;vertical-align:-0.136em;"></span><span class="mrel">â‰¤</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span></li>
<li>The total value is <strong>maximized</strong></li>
</ul>
<h4 id="Brute-force-Method">Brute force Method</h4>
<h5 id="Idea">Idea</h5>
<p>For each item, we have two choices:</p>
<ul>
<li><strong>Include it</strong> (if weight allows)</li>
<li><strong>Exclude it</strong></li>
</ul>
<p>This naturally leads to a binary decision tree of size <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6644em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span>:</p>
<ul>
<li><strong>Depth</strong> = number of items <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></li>
<li><strong>Each path</strong> = one subset of items</li>
</ul>
<h5 id="Recursive-Solution">Recursive Solution</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_bruteforce</span>(<span class="params">weights, values, capacity, n</span>):</span><br><span class="line">    <span class="comment"># Base case: no items or no capacity</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">or</span> capacity == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># If weight of nth item &gt; capacity, we can't take it</span></span><br><span class="line">    <span class="keyword">if</span> weights[n-<span class="number">1</span>] &gt; capacity:</span><br><span class="line">        <span class="keyword">return</span> knapsack_bruteforce(weights, values, capacity, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Two choices: include or exclude the nth item</span></span><br><span class="line">    include = values[n-<span class="number">1</span>] + knapsack_bruteforce(weights, values, capacity - weights[n-<span class="number">1</span>], n-<span class="number">1</span>)</span><br><span class="line">    exclude = knapsack_bruteforce(weights, values, capacity, n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(include, exclude)</span><br></pre></td></tr></tbody></table></figure>
<h5 id="How-it-Works">How it Works</h5>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">               {}</span><br><span class="line">         /            \</span><br><span class="line">      {<span class="selector-tag">A</span>}             {}</span><br><span class="line">    /     \         /     \</span><br><span class="line">{<span class="selector-tag">A</span>,<span class="selector-tag">B</span>}   {<span class="selector-tag">A</span>}     {<span class="selector-tag">B</span>}       {}</span><br><span class="line">...      ...    ...        ...</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Example-Setup">Example Setup</h5>
<ul>
<li><strong>Weights</strong>: [1, 2]</li>
<li><strong>Values</strong>: [4, 5]</li>
<li><strong>Capacity</strong>: 2</li>
<li><strong>n</strong> = 2 items</li>
</ul>
<p><strong>First call:</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">knapsack_bruteforce([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">4</span>,<span class="number">5</span>], <span class="number">2</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Item n=2</strong>: weight = 2, value = 5</li>
<li>Capacity = 2 â†’ weight â‰¤ capacity â†’ two choices:</li>
</ul>
<ol>
<li>
<p><strong>Include item 2</strong><br>
â†’ Value = 5 + knapsack(capacity = 2-2=0, n = 1)<br>
â†’ Inner call returns 0 because capacity = 0 â†’ total = 5</p>
</li>
<li>
<p><strong>Exclude item 2</strong><br>
â†’ Call knapsack(capacity = 2, n = 1) â†’ check item 1 next.</p>
</li>
</ol>
<p><strong>Second call (exclude branch):</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line">knapsack_bruteforce([<span class="number">1</span>,<span class="number">2</span>], [<span class="number">4</span>,<span class="number">5</span>], <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Item n=1</strong>: weight = 1, value = 4</li>
<li>Capacity = 2 â†’ weight â‰¤ capacity â†’ two choices:</li>
</ul>
<ol>
<li>
<p><strong>Include item 1</strong><br>
â†’ Value = 4 + knapsack(capacity = 2-1=1, n = 0) = 4 + 0 = 4</p>
</li>
<li>
<p><strong>Exclude item 1</strong><br>
â†’ Call knapsack(capacity = 2, n = 0) = 0</p>
</li>
</ol>
<p>Max here = <strong>4</strong></p>
<p><strong>Summary Table</strong></p>
<table>
<thead>
<tr>
<th>Path</th>
<th>Items Taken</th>
<th>Total Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>Include item 2</td>
<td>{2}</td>
<td>5</td>
</tr>
<tr>
<td>Exclude item 2 â†’ Include item 1</td>
<td>{1}</td>
<td>4</td>
</tr>
<tr>
<td>Exclude item 2 â†’ Exclude item 1</td>
<td>{}</td>
<td>0</td>
</tr>
</tbody>
</table>
<p><strong>Max value = 5 â†’ Take item 2 only.</strong></p>
<h4 id="From-Brute-Force-to-2D-DP-How-We-Simplify-0-1-Knapsack">From Brute Force to 2D DP: How We Simplify 0/1 Knapsack</h4>
<p>The 0/1 Knapsack problem starts simple:<br>
For each item, we can either <strong>take it</strong> or <strong>leave it</strong>.</p>
<p>At every step, we have two choices:</p>
<ol>
<li><strong>Include</strong> the current item if it fits â†’ move to the next item with reduced capacity</li>
<li><strong>Exclude</strong> the current item â†’ move to the next item with the same capacity</li>
</ol>
<p>This brute-force approach explores <strong>all possible subsets</strong>, leading to a time complexity of:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
O(2^n)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
<h5 id="Step-1-Realizing-the-Repeated-Work">Step 1: Realizing the Repeated Work</h5>
<p><strong>recursion tree</strong></p>
<ul>
<li>Item 1: weight = 1, value = 1</li>
<li>Item 2: weight = 2, value = 5</li>
<li>Capacity = 3</li>
</ul>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line">Start: (i=<span class="number">2</span>, capacity=<span class="number">3</span>)</span><br><span class="line">Item <span class="number">2</span>: weight=<span class="number">2</span>, value= <span class="number">5</span></span><br><span class="line">                        (i=<span class="number">2</span>, cap=<span class="number">3</span>)</span><br><span class="line">                         /        \</span><br><span class="line">            Exclude item2          Include item2</span><br><span class="line">               (i=<span class="number">1</span>, cap=<span class="number">3</span>)           (i=<span class="number">1</span>, cap=<span class="number">1</span>)</span><br><span class="line">                /      \                  /      \</span><br><span class="line">  Exclude item1   Include item1   Exclude item1   Include item1</span><br><span class="line">   (i=<span class="number">0</span>,<span class="number">3</span>)         (i=<span class="number">0</span>,<span class="number">2</span>)         (i=<span class="number">0</span>,<span class="number">1</span>)         (i=<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>When we draw the recursion tree, we notice something important:</p>
<ul>
<li>Many branches <strong>reach the same subproblem</strong> again and again.</li>
</ul>
<p>From the recursive tree we see:</p>
<p>Two different paths reach the <strong>same subproblem</strong> <code>(i=1, cap=1)</code>:</p>
<ul>
<li>Path A: <strong>Include</strong> item 3 (cap: 2 â†’ 1) â†’ <strong>Exclude</strong> item 2 â†’ <code>(i=1, cap=1)</code></li>
<li>Path B: <strong>Exclude</strong> item 3 (cap: 2) â†’ <strong>Include</strong> item 2 (2 â†’ 1) â†’ <code>(i=1, cap=1)</code></li>
</ul>
<p>Both paths lead to the <strong>same <code>(i, cap)</code></strong>, but brute force recomputes it each time.</p>
<h5 id="Step-2-Memoization-to-the-Rescue">Step 2: Memoization to the Rescue</h5>
<p>To avoid recomputing, we add a <strong>dictionary (memo)</strong>:</p>
<ul>
<li>
<p>Every time we solve a subproblem <code>(i, capacity)</code>,<br>
we <strong>store</strong> the result in <code>memo[(i, capacity)]</code>.</p>
</li>
<li>
<p>If the same <code>(i, capacity)</code> appears again,<br>
we <strong>look it up</strong> instead of recomputing.</p>
</li>
</ul>
<p>This immediately cuts down all <strong>duplicate work</strong>:<br>
Each subproblem is solved <strong>only once</strong>.</p>
<p><strong>Result</strong>:<br>
The recursion tree shrinks, and time complexity drops from <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(2^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> to <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>Ã—</mo><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \times W)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mclose">)</span></span></span></span>,<br>
because there are only <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>Ã—</mo><mi>W</mi></mrow><annotation encoding="application/x-tex">n \times W</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span> unique subproblems.</p>
<h5 id="Step-3-Moving-to-2D-DP">Step 3: Moving to 2D DP</h5>
<p>Memoization naturally leads to the idea of a <strong>DP table</strong>:</p>
<ul>
<li>Instead of a dictionary, we use a <strong>2D array</strong> <code>dp[i][w]</code></li>
<li><code>dp[i][w]</code> = maximum value using the <strong>first i items</strong> with <strong>capacity w</strong></li>
<li>We fill the table iteratively so each subproblem is solved <strong>exactly once</strong> in a structured order</li>
</ul>
<p><strong>Recurrence</strong></p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable rowspacing="0.36em" columnalign="left left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if&nbsp;</mtext><msub><mi>w</mi><mi>i</mi></msub><mo>&gt;</mo><mi>w</mi></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>max</mi><mo>â¡</mo><mo stretchy="false">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>w</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>â€…â€Š</mtext><msub><mi>v</mi><mi>i</mi></msub><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>w</mi><mo>âˆ’</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">
dp[i][w] =
\begin{cases}
dp[i-1][w] &amp; \text{if } w_i &gt; w \\
\max(dp[i-1][w], \; v_i + dp[i-1][w - w_i]) &amp; \text{otherwise}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3em;vertical-align:-1.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">{</span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mop">max</span><span class="mopen">(</span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">])</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.69em;"><span style="top:-3.69em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">if&nbsp;</span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span></span></span><span style="top:-2.25em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:1.19em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p><strong>Complexity</strong></p>
<ul>
<li><strong>Time</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(nW) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">nW</span><span class="mclose">)</span></span></span></span></li>
<li><strong>Space</strong>: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>W</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(nW) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.13889em;">nW</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>A huge improvement over the original <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mn>2</mn><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex"> O(2^n) </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> brute force.</p>
<h5 id="2D-DP-Solution">2D DP Solution</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_dp_2d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    <span class="comment"># dp[i][w] = max value using first i items with capacity w</span></span><br><span class="line">    dp = [[<span class="number">0</span>] * (capacity + <span class="number">1</span>) <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(n + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Build table iteratively</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):                 <span class="comment"># items 1..n</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, capacity + <span class="number">1</span>):      <span class="comment"># capacity 1..W</span></span><br><span class="line">            <span class="keyword">if</span> weights[i-<span class="number">1</span>] &gt; w:</span><br><span class="line">                <span class="comment"># can't take item i-1</span></span><br><span class="line">                dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># choose max of including or excluding item i-1</span></span><br><span class="line">                include = values[i-<span class="number">1</span>] + dp[i-<span class="number">1</span>][w - weights[i-<span class="number">1</span>]]</span><br><span class="line">                exclude = dp[i-<span class="number">1</span>][w]</span><br><span class="line">                dp[i][w] = <span class="built_in">max</span>(include, exclude)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[n][capacity]</span><br></pre></td></tr></tbody></table></figure>
<h4 id="From-2D-DP-to-1D-DP">From 2D DP to 1D DP</h4>
<h5 id="Insight">Insight</h5>
<p>When we first built the 2D DP table for 0/1 Knapsack, each cell</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>â¡</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>â€…â€Š</mtext><msub><mi>v</mi><mi>i</mi></msub><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>i</mi><mo>âˆ’</mo><mn>1</mn><mo stretchy="false">]</mo><mo stretchy="false">[</mo><mi>j</mi><mo>âˆ’</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">
dp[i][j] = \max \bigl( dp[i-1][j], \; v_i + dp[i-1][j - w_i] \bigr)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose"><span class="delimsizing size1">)</span></span></span></span></span></span>
<p>represented the <strong>best value</strong> for the first <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> items and capacity <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex"> j </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span>.</p>
<p>But if we look closely:</p>
<ul>
<li>Every update for <strong>row i</strong> depends <strong>only</strong> on <strong>row i-1</strong></li>
<li>Once we finish <strong>row i</strong>, we never touch <strong>row i-1</strong> again</li>
</ul>
<p><strong>Key</strong><br>
We donâ€™t need the entire 2D table.<br>
We can just <strong>reuse the same row</strong> over and over,</p>
<p><strong>The Mental Shift</strong></p>
<p>Imagine we keep a single <strong>1D array</strong> <code>dp[j]</code> for capacities <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn><mo>â€¦</mo><mi>W</mi></mrow><annotation encoding="application/x-tex"> 0 \ldots W </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">â€¦</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span></span></span></span>.</p>
<p>While processing item <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>:</p>
<ul>
<li><strong>Before update:</strong> <code>dp[j]</code> = best value <strong>before</strong> using item <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></li>
<li><strong>After update:</strong> <code>dp[j]</code> = best value <strong>after</strong> using item <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span></li>
</ul>
<p>But thereâ€™s a catch:</p>
<ul>
<li>If we update <code>dp[j]</code> <strong>left â†’ right</strong>,<br>
the new value of <code>dp[j - w_i]</code> might already include item <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex"> i </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>, so weâ€™d <strong>count it twice</strong>.</li>
<li>To avoid this, we go <strong>rightâ†’left</strong>, so we always use the old value first. This keeps the logic correct while collapsing two dimensions into one.</li>
</ul>
<p><strong>Formula</strong></p>
<p>Now the recurrence becomes:</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo>=</mo><mi>max</mi><mo>â¡</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">(</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo stretchy="false">]</mo><mo separator="true">,</mo><mtext>â€…â€Š</mtext><msub><mi>v</mi><mi>i</mi></msub><mo>+</mo><mi>d</mi><mi>p</mi><mo stretchy="false">[</mo><mi>j</mi><mo>âˆ’</mo><msub><mi>w</mi><mi>i</mi></msub><mo stretchy="false">]</mo><mo fence="true" stretchy="true" minsize="1.2em" maxsize="1.2em">)</mo></mrow><annotation encoding="application/x-tex">
dp[j] = \max \bigl(dp[j], \; v_i + dp[j - w_i] \bigr)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mop">max</span><span class="mopen"><span class="delimsizing size1">(</span></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">p</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.2em;vertical-align:-0.35em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0269em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">]</span><span class="mclose"><span class="delimsizing size1">)</span></span></span></span></span></span>
<p>with ( j ) iterating <strong>from ( W ) down to ( w_i )</strong>.</p>
<h5 id="1D-DP-Solution">1D DP Solution</h5>
<figure class="highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">knapsack_dp_1d</span>(<span class="params">weights, values, capacity</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(weights)</span><br><span class="line">    dp = [<span class="number">0</span>] * (capacity + <span class="number">1</span>)  <span class="comment"># dp[w] = best value for capacity w so far</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n + <span class="number">1</span>):        <span class="comment"># items 1..n</span></span><br><span class="line">        w_i, v_i = weights[i-<span class="number">1</span>], values[i-<span class="number">1</span>]</span><br><span class="line">        <span class="comment"># Right â†’ left so we use previous row values before overwriting</span></span><br><span class="line">        <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(capacity, w_i - <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">            dp[w] = <span class="built_in">max</span>(dp[w], v_i + dp[w - w_i])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[capacity]</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>DataStructure-Algorithms</category>
      </categories>
      <tags>
        <tag>DataStructure Algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>Build a Blog from Scratch with Hexo and GitHub Pages</title>
    <url>/2025/08/26/Guides/Building-a-Blog-with-GitHub-and-Hexo/</url>
    <content><![CDATA[<p>Do you want to start your own blog for free?<br>
In this tutorial, Iâ€™ll show you how to build a blog <strong>from scratch</strong> using <a href="https://hexo.io/">Hexo</a> (a fast, Node.js-based blogging framework) and deploy it to <strong>GitHub Pages</strong> for free hosting.</p>
<hr>
<h2 id="Step-0-Install-Node-js">Step 0: Install Node.js</h2>
<p>Check if Node.js and npm are installed:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></tbody></table></figure>
<p>If missing (or you want a specific version), install via NodeSource. Example for Node 22:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">curl -fsSL https://deb.nodesource.com/setup_22.x | <span class="built_in">sudo</span> -E bash -</span><br><span class="line"><span class="built_in">sudo</span> apt install -y nodejs</span><br></pre></td></tr></tbody></table></figure>
<p>Verify installation:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Step-1-Install-Hexo-Create-Your-Blog">Step 1: Install Hexo &amp; Create Your Blog</h2>
<p>Install Hexo CLI globally:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> npm i -g hexo-cli</span><br></pre></td></tr></tbody></table></figure>
<p>Create a new blog project:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init my-blog</span><br><span class="line"><span class="built_in">cd</span> my-blog</span><br><span class="line">npm install</span><br></pre></td></tr></tbody></table></figure>
<p>Or use the current folder:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo init .</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Step-2-Write-Your-First-Blog-Post">Step 2: Write Your First Blog Post</h2>
<p>Create a new post:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo new post <span class="string">"Hello World"</span></span><br></pre></td></tr></tbody></table></figure>
<p>Edit the generated file <code>source/_posts/hello-world.md</code>:</p>
<figure class="highlight markdown"><table><tbody><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hello World</span><br><span class="line">date: 2025-08-26 22:00:00</span><br><span class="line"><span class="section">tags: [Intro]</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">Welcome to my first Hexo blog post!   </span><br><span class="line">This is written in <span class="strong">**Markdown**</span>.</span><br></pre></td></tr></tbody></table></figure>
<p>Preview locally:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure>
<p>Visit: <a href="http://localhost:4000">http://localhost:4000</a></p>
<hr>
<h2 id="Step-3-Install-a-Theme">Step 3: Install a Theme</h2>
<p>Install the <strong>Next</strong> theme:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></tbody></table></figure>
<p>Edit <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></tbody></table></figure>
<p>Restart:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo server</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Step-4-Deploy-to-GitHub-Pages">Step 4: Deploy to GitHub Pages</h2>
<p>Create a repo on GitHub (e.g. <code>my-blog</code>).<br>
If your username is <code>yourname</code>:</p>
<figure class="highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line">https://yourname.github.io/my-blog/</span><br></pre></td></tr></tbody></table></figure>
<p>Install deployer:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure>
<p>Edit <code>_config.yml</code>:</p>
<figure class="highlight yaml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/yourname/my-blog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></tbody></table></figure>
<p>Deploy:</p>
<figure class="highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h2 id="Step-5-Extra-Tweaks">Step 5: Extra Tweaks</h2>
<p>Apple-style fonts:</p>
<figure class="highlight css"><table><tbody><tr><td class="code"><pre><span class="line"><span class="selector-tag">body</span> {</span><br><span class="line">  <span class="attribute">font-family</span>: -apple-system, BlinkMacSystemFont, <span class="string">"Helvetica Neue"</span>, Arial, sans-serif;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Custom domain: create <code>source/CNAME</code> with your domain name.</p>
<p>SEO &amp; Analytics: configure in theme <code>_config.yml</code>.</p>
<hr>
]]></content>
      <categories>
        <category>Guides</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ chapter</title>
    <url>/2025/08/28/Interview/C++/</url>
    <content><![CDATA[<h1>Common C++ Interview Questions</h1>
<h2 id="C-Basics">C++ Basics</h2>
<h3 id="Difference-Between-Pointers-and-References">Difference Between Pointers and References</h3>
<p>A <strong>pointer</strong> stores the address of an object. It is itself a variable(a named object) and has its own address, so you can even have a pointer to a pointer.<br>
A pointer can be changed â€“ both the address it stores and the data at that address be modified.</p>
<p>A <strong>reference</strong> is simply an alias for a variable. Once bound, it cannot be changed to refer to another object, and it must be initialized when declared.</p>
<p>There is no such things as a â€œnull referenceâ€, but there can be a pointer to a null value.</p>
<p><strong>1. Definition and Declaration:</strong></p>
<p>A pointer is a variable whose value is the address of another variable.<br>
When declaring a pointer, the <code>*</code> is used.</p>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">*ptr = &amp;x;</span><br></pre></td></tr></tbody></table></figure>
<p>A reference is an alias, created for an already existing variable. When declaring a reference, the <code>&amp;</code> is used.</p>
<p><strong>2. Usage and Operations:</strong></p>
<ul>
<li><strong>Pointer:</strong> By using the dereference operator <code>*</code>, you can access the value of the variable the pointer pointes to. You can also use the address-of operator <code>&amp;</code> to obtain the address of a variable.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> value = *ptr; <span class="comment">// get the value of the variable the the pointer points to</span></span><br><span class="line"><span class="type">int</span> address = &amp;x; <span class="comment">// obtain the address of variable x</span></span><br></pre></td></tr></tbody></table></figure>
<ul>
<li><strong>Reference:</strong> A reference must be initialized when declared, and throughout its entire lifetime, it always refers to the same variable. You donâ€™t need to use the dereference operator, because a reference itself is just another name for the variable.</li>
</ul>
<figure class="highlight c++"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> newValue = ref; <span class="comment">// get the reference value</span></span><br></pre></td></tr></tbody></table></figure>
<p><strong>3. Null Pointers and Null References:</strong></p>
<p>A pointer can be null(<code>nullptr</code>), meaning it does not point to any valid address.</p>
<p>A reference must be initialized at the time of declaration, and it cannot be changed to refer to a different object. Therefore, there is no concept of a null reference.</p>
<p><strong>4. Mutability:</strong></p>
<ul>
<li>
<p><strong>Pointer:</strong> A pointer can change what it points to, allowing it to refer to different memory addresses.</p>
</li>
<li>
<p><strong>Reference:</strong> Once a reference is initialized, it always refers to the same object and cannot be rebound.</p>
</li>
</ul>
<p><strong>5. Usage:</strong></p>
<ul>
<li>
<p><strong>Pointer:</strong> Commonly used for dynamic memory allocation, array operations, and function parameter passing.</p>
</li>
<li>
<p><strong>Reference:</strong> Commonly used for function parameter passing, operator overloading, and create aliases.</p>
</li>
</ul>
<h3 id="Data-Types">Data Types</h3>
<p><strong>Interger Types: <code>short</code>, <code>int</code>, <code>long</code>, and <code>long long</code></strong></p>
<ul>
<li><code>short:</code> at least 16 bits</li>
<li><code>int:</code> at least as long as short</li>
<li><code>long:</code> at least 32 bits, and at least as long as <code>int</code></li>
<li><code>long long</code>: at least 64 bits, and at least as long as <code>long</code></li>
</ul>
<p>1 bytes is at least 8 bits. On modern system, a byte is always 8 bits.</p>
<h3 id="Keyword">Keyword</h3>
<h4 id="const-Keyword"><code>const</code> Keyword</h4>
<p><strong>Purpose of <code>const</code></strong><br>
A variable or object qualified with <code>const</code> cannot be modified; it becomes read-only.<br>
A <code>const</code> variable must be initialized at the point of definition.</p>
<h5 id="1-Constant-Pointer-a-k-a-â€œpointer-to-constâ€">1. Constant Pointer (a.k.a. â€œpointer to constâ€)</h5>
<p>A <em>constant pointer</em> means the pointer points to an object that cannot be modified through that pointer.<br>
In other words, the pointer enforces immutable on the object it refers to.</p>
<p><strong>Key property</strong></p>
<ul>
<li>The pointer itself can still be reassigned to point to another object.</li>
<li>What is constant is the value being point to, not the pointer address.</li>
</ul>
<p><strong>Syntax Forms</strong></p>
<ol>
<li><code>const DadaType* ptr = variableName;</code><br>
or equivalently:<br>
<code>DataType const* ptr = variableName;</code><br>
-&gt; Pointer to an constant object(object cannot be modified through <code>ptr</code>).</li>
<li><code>DataType* const ptr = variableName;</code><br>
-&gt; Constant pointer (the pointer itself cannot be reassigned, but the object it points to can be modified).</li>
</ol>
<p><strong>Example</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* a = &amp;temp;</span><br><span class="line"><span class="type">int</span> <span class="type">const</span>* a = &amp;temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modification:</span></span><br><span class="line">*a = <span class="number">9</span>;     <span class="comment">// âŒ Error: cannot modify a read-only object through this pointer</span></span><br><span class="line">temp = <span class="number">9</span>;   <span class="comment">// âœ… Valid: the variable itself is not declared const</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-Const-Pointer-T-const">2. Const Pointer (<code>T* const</code>)</h5>
<p><strong>Definition</strong><br>
A <strong>const pointer</strong> means that pointerâ€™s address is fixed once initialized â€“ you cannot make it point to another location afterwards.<br>
What is constant here is the pointer itself, not the data it points to.</p>
<p><strong>Key Property</strong></p>
<ul>
<li>The pointer must be initialized at the time of definition.</li>
<li>After initialization, you cannot reassign it to another address.</li>
<li>The object being pointed to remains mutable(unless it was declared <code>const</code> separately).</li>
<li><strong>Syntax</strong></li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">DataType* <span class="type">const</span> pointerName = &amp;varaible;</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Example</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> temp1 = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> p = &amp;temp;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modification:</span></span><br><span class="line">p = &amp;temp1;  <span class="comment">// âŒ Error: p is a const pointer, cannot change its address</span></span><br><span class="line">*p = <span class="number">9</span>;      <span class="comment">// âœ… Valid: the pointee (temp) is still mutable</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="The-Role-of-the-static-Keyword">The Role of the <code>static</code> Keyword</h4>
<p>The <code>static</code> keyword is mainly used to control the lifecycle of variables and functions, their scope, and access permissions.</p>
<h5 id="1-Static-Variables">1. Static Variables</h5>
<ul>
<li>Variables declared with the <code>static</code> keyword inside a function are called static variables.</li>
<li>Static variables exist throughout the entire lifetime of the program and are not destroyed when leaving the function scope.</li>
<li>Static variables are initialized to zero by default (for basic data types).</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// static variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"Count: "</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h5 id="2-Static-Functions">2. Static Functions</h5>
<ul>
<li>Functions declared with the <code>static</code> keyword inside a class are static member functions.</li>
<li>Static member functions belong to the class rather than to an instance, and can be called directly using the class name without creating an object.</li>
<li>Static member functions cannot directly access non-static member variables or non-static member functions.</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">staticFunction</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Static function"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-Static-Member-Variables">3. Static Member Variables</h5>
<ul>
<li>
<p>Member variables declared with the static keyword inside a class are static member variables.</p>
</li>
<li>
<p>All objects of the class share the same static member variable.</p>
</li>
<li>
<p>Static member variables must be defined once outside the class so memory can be allocated for them.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleClass</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;   <span class="comment">// declaration of static member variable</span></span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">// definition of static member variable</span></span><br><span class="line"><span class="type">int</span> ExampleClass::staticVar = <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure>
<h5 id="4-Static-Member-Functions">4. Static Member Functions</h5>
<ul>
<li>
<p>Member functions declared with the static keyword inside a class are static member functions.</p>
</li>
<li>
<p>Static member functions cannot directly access non-static member variables or non-static member functions.</p>
</li>
<li>
<p>Static member functions can be called using the class name without creating an instance.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTool</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>{     <span class="comment">// static member function</span></span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="comment">// Call the static function using the class name</span></span><br><span class="line">    <span class="type">int</span> result = MathTool::<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;  <span class="comment">// Output: 8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>add</code> is a static member function</p>
<p>It belongs to the class, not to any object.</p>
<p>You DONâ€™T need to write:</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">MathTool tool;</span><br><span class="line">tool.<span class="built_in">add</span>(<span class="number">3</span>, <span class="number">5</span>);   <span class="comment">// âŒ Not required</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="5-Static-Local-Variables">5. Static Local Variables</h5>
<ul>
<li>
<p>Local variables declared with the static keyword inside a function are static local variables.</p>
</li>
<li>
<p>The lifetime of a static local variable lasts for the entire program execution, but it is only visible inside the function where it is declared.</p>
</li>
</ul>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">exampleFunction</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> localVar = <span class="number">0</span>;   <span class="comment">// static local variable</span></span><br><span class="line">    localVar++;</span><br><span class="line">    cout &lt;&lt; <span class="string">"LocalVar: "</span> &lt;&lt; localVar &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="The-Role-of-the-const-Keyword">The Role of the <code>const</code> Keyword</h4>
<p>The <code>const</code> keyword is mainly used to specify that variables, pointers, references, and member functions cannot be modified.</p>
<h5 id="1-Constant-Variables">1. Constant Variables</h5>
<p>Declaring a constant variable makes its value unmodifiable.</p>
<h5 id="2-Pointers-and-References">2. Pointers and References</h5>
<p>Declaring a pointer to a constant means the value pointed to cannot be modified through the pointer.<br>
Declaring a constant reference means the referenced value is constant and cannot be modified through the reference.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;constantValue;   <span class="comment">// pointer to constant</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>&amp; ref = constantValue;    <span class="comment">// constant reference</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="3-Member-Functions">3. Member Functions</h5>
<p>Used to declare constant member functions, meaning the function will not modify member variables of the object (when those member variables are non-static).</p>
<h5 id="4-Constant-Objects">4. Constant Objects</h5>
<p>Declaring an object as constant makes all its member variables unmodifiable.</p>
<h5 id="5-Constant-Reference-Parameters">5. Constant Reference Parameters</h5>
<p>Declaring a function parameter as a constant reference means the function will not modify the passed-in argument.</p>
<h5 id="6-Constant-Pointer-Parameters">6. Constant Pointer Parameters</h5>
<p>Declaring a function parameter as a pointer to a constant means the function cannot modify the data pointed to by the pointer.</p>
<h4 id="Differences-Between-define-and-typedef">Differences Between <code>define</code> and <code>typedef</code></h4>
<h4 id="define">define</h4>
<ol>
<li>It is only a simple text substitution, with no type checking.</li>
<li>It takes effect during the preprocessing stage of compilation.</li>
<li>It can be used to prevent multiple inclusion of header files.</li>
<li>It does not allocate memory; the value is replaced every time it is used.</li>
</ol>
<h4 id="typedef">typedef</h4>
<ol>
<li>It has a corresponding data type, and type checking is performed.</li>
<li>It takes effect during compilation and runtime.</li>
<li>Space is allocated in static storage; during program execution, there is only one copy in memory.</li>
</ol>
<h4 id="Differences-Between-define-and-inline">Differences Between <code>define</code> and <code>inline</code></h4>
<h5 id="1-define">1. define</h5>
<p>A macro handled by the preprocessor. It is only a simple text substitution, has no type checking, and is unsafe.</p>
<h5 id="2-inline">2. inline</h5>
<p>Inline functions are compiled first and their function bodies are inserted directly at the call site, reducing stack operations, jumps, and returns. There is no overhead of a normal function call.</p>
<p>An inline function is a special type of function and will be type-checked.</p>
<p>A request to the compiler to inline the function â€” the compiler may reject this request.</p>
<h5 id="Restrictions-on-inline-in-C">Restrictions on inline in C++</h5>
<ol>
<li>Inline functions cannot contain any form of loop statements.</li>
<li>Inline functions cannot contain too many conditional statements.</li>
<li>The function body cannot be too large.</li>
<li>Inline functions must be defined before they are called.</li>
</ol>
<h4 id="Differences-Between-const-and-define">Differences Between <code>const</code> and <code>define</code></h4>
<p><code>const</code> is used to define constants; <code>define</code> is used to define macros, and macros can also be used to define constants. When both are used to define constants, their differences include:</p>
<ol>
<li><code>const</code> takes effect during the compilation stage; <code>define</code> takes effect during the preprocessing stage.</li>
<li>Constants defined with <code>const</code> are stored in memory in C and require extra memory space; constants defined with <code>define</code> are replaced directly during runtime and are not stored in memory.</li>
<li>Constants defined with <code>const</code> have types; constants defined with <code>define</code> do not have types. Therefore, <code>define</code> constants are not helpful for type checking.</li>
</ol>
<h4 id="Differences-Between-new-and-malloc">Differences Between <code>new</code> and <code>malloc</code></h4>
<ol>
<li>When <code>new</code> fails to allocate memory, it throws a <code>bad_alloc</code> exception and does not return NULL; when <code>malloc</code> fails, it returns NULL.</li>
<li>When using the <code>new</code> operator to allocate memory, you do not need to specify the size of the memory block; <code>malloc</code> requires you to explicitly specify the size of the required memory.</li>
<li><code>operator new</code> and <code>operator delete</code> can be overloaded, whereas <code>malloc</code>/<code>free</code> cannot be overloaded.</li>
<li><code>new</code>/<code>delete</code> will call the constructor/destructor of objects to complete object construction/destruction; <code>malloc</code> will not.</li>
<li><code>malloc</code> and <code>free</code> are standard functions of C/C++, while <code>new</code>/<code>delete</code> are C++ operators.</li>
<li>The <code>new</code> operator allocates dynamic memory from the free store (heap) for objects; <code>malloc</code> allocates dynamic memory from the heap as well.</li>
</ol>
<h5 id="Comparison-Table">Comparison Table</h5>
<table>
<thead>
<tr>
<th>Category</th>
<th>new/delete (C++)</th>
<th>malloc/free (C/C++)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nature</td>
<td>Operator</td>
<td>CRT library function</td>
</tr>
<tr>
<td>Memory Size</td>
<td>Automatically calculated</td>
<td>Manually specified</td>
</tr>
<tr>
<td>Type Safety</td>
<td>Yes (type-checked)</td>
<td>No (e.g., casting <code>malloc</code> result to different types wonâ€™t cause an error)</td>
</tr>
<tr>
<td>Relationship</td>
<td><code>new</code> is implemented using <code>malloc</code></td>
<td>Only allocates and frees memory</td>
</tr>
<tr>
<td>Other Features</td>
<td>Calls constructors/destructors</td>
<td>Does not call constructors/destructors</td>
</tr>
<tr>
<td></td>
<td>Throws <code>bad_alloc</code> on failure</td>
<td>Returns <code>NULL</code> on failure</td>
</tr>
<tr>
<td>Pointer Type</td>
<td>Returns a pointer of the exact type</td>
<td>Returns <code>void*</code>, requires type casting</td>
</tr>
</tbody>
</table>
<h4 id="constexpr-and-const">constexpr and const</h4>
<p>const represents read-only semantics, while constexpr represents constant-expression semantics.</p>
<p>constexpr can only define compile-time constants, whereas const can define compile-time constants as well as run-time constants.</p>
<p>If you mark a member function as constexpr, it is implicitly also marked as const.<br>
If you mark a variable as constexpr, it is also const.<br>
However, the reverse does not hold: a const variable or function is not necessarily constexpr.</p>
<h5 id="constexpr-Variables">constexpr Variables</h5>
<p>In complex systems, it can be difficult to determine whether an initializer is a constant expression.</p>
<p>You can declare a variable as <code>constexpr</code> and let the compiler verify whether its value is a constant expression.</p>
<p><strong>Must be initialized with a constant expression:</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> n = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> m = n + <span class="number">1</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> MOD = <span class="number">1000000007</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>If a pointer is declared using constexpr, constexpr applies only to the pointer itself, not to the object it points to.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span>* p = <span class="literal">nullptr</span>;     <span class="comment">// constant pointer (top-level const)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* q = <span class="literal">nullptr</span>;         <span class="comment">// pointer to const (low-level const)</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> r = <span class="literal">nullptr</span>;         <span class="comment">// constant pointer (top-level const)</span></span><br></pre></td></tr></tbody></table></figure>
<h5 id="constexpr-Functions">constexpr Functions</h5>
<p>A <code>constexpr</code> function is a function that can be used in a constant expression.</p>
<p>The return type and all parameter types must be literal types, and the function body must contain exactly one <code>return</code> statement.</p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_value</span><span class="params">()</span> </span>{ <span class="keyword">return</span> <span class="number">42</span>; }</span><br></pre></td></tr></tbody></table></figure>
<p>To allow expansion during compilation, a <code>constexpr</code> function is implicitly treated as an inline function.</p>
<p><code>constexpr</code> functions and inline functions can be defined multiple times in a program, and are typically defined in header files.</p>
<h3 id="Difference-Between-Constant-Pointer-and-Pointer-to-Constant">Difference Between Constant Pointer and Pointer to Constant</h3>
<ul>
<li>
<p>A constant pointer means the pointer itself is constant, but the content it points to can be changed.</p>
</li>
<li>
<p>A pointer to constant means the content pointed to is constant, but the pointer itself can be changed.</p>
</li>
<li>
<p>In a constant pointer, the keyword const appears after *.</p>
</li>
<li>
<p>In a pointer to constant, the keyword const appears before *.</p>
</li>
</ul>
<h3 id="Differences-Between-struct-and-class">Differences Between struct and class</h3>
<ul>
<li>
<p>Generally, <code>struct</code> is used to represent a group of related data, while <code>class</code> is used to represent an object that encapsulates both data and operations.<br>
In practice, you can choose between <code>struct</code> and <code>class</code> based on actual needs.<br>
If the purpose is only to organize some data without complex encapsulation or inheritance, <code>struct</code> may be more straightforward.<br>
If encapsulation, inheritance, and other object-oriented features are required, <code>class</code> is usually preferred.</p>
</li>
<li>
<p>Members in a <code>struct</code> are <strong>public</strong> by default.<br>
Members in a <code>class</code> are <strong>private</strong> by default.</p>
</li>
<li>
<p>When using inheritance, <code>struct</code> uses <strong>public inheritance</strong> by default,<br>
while <code>class</code> uses <strong>private inheritance</strong> by default.</p>
</li>
<li>
<p>If a <code>struct</code> does not define any constructors, the compiler will generate a default no-argument constructor.<br>
If a <code>class</code> does not define any constructors, the compiler will also generate a default no-argument constructor.</p>
</li>
</ul>
<h3 id="Difference-Between-Local-Variables-and-Static-Local-Variables">Difference Between Local Variables and Static Local Variables</h3>
<h4 id="1-Local-Variables">1. Local Variables</h4>
<p>A local variable is a variable defined inside a function or block.</p>
<h5 id="Characteristics">Characteristics</h5>
<ul>
<li><strong>Scope</strong>: Limited to the block or function where it is defined</li>
<li><strong>Lifetime</strong>: Exists only while the block is executing</li>
<li><strong>Storage</strong>: Typically allocated on the stack</li>
<li><strong>Initialization</strong>: Re-initialized every time the function is called</li>
<li><strong>Value retention</strong>: âŒ Does not retain value between calls</li>
</ul>
<h5 id="Example">Example</h5>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// local variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Output if called multiple times:</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></tbody></table></figure>
<h4 id="2-Static-Local-Variables">2. Static Local Variables</h4>
<p>A static local variable is a local variable declared with the static keyword.</p>
<h5 id="Characteristics-2">Characteristics</h5>
<ul>
<li><strong>Scope</strong>: Limited to the function where it is defined</li>
<li><strong>Lifetime</strong>: Exists for the entire program execution</li>
<li><strong>Storage</strong>: Allocated in static storage area</li>
<li><strong>Initialization</strong>: Initialized only once</li>
<li><strong>Value retention</strong>: âœ… Retains value between function calls</li>
</ul>
<h5 id="Example-2">Example</h5>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">// static local variable</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>Output if called multiple times:</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></tbody></table></figure>
<h3 id="Upcasting-vs-Downcasting-C">Upcasting vs Downcasting (C++)</h3>
<h4 id="1ï¸âƒ£-What-Is-Upcasting">1ï¸âƒ£ What Is Upcasting?</h4>
<h5 id="Definition">Definition</h5>
<p>Upcasting is converting a derived-class pointer or reference<br>
to a base-class pointer or reference.</p>
<p><strong>Derived â†’ Base</strong><br>
A <code>Derived</code> object looks like this in memory:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">[ Base part ][ Derived extra part ]</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Example-3">Example</h5>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">foo</span><span class="params">()</span> </span>{}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line">Derived d;</span><br><span class="line">Base* b = &amp;d;   <span class="comment">// upcasting</span></span><br></pre></td></tr></tbody></table></figure>
<p>âœ” Always safe<br>
âœ” Happens implicitly<br>
âœ” No cast required<br>
âœ” No runtime cost</p>
<h5 id="Why-Upcasting-Is-Safe">Why Upcasting Is Safe</h5>
<ul>
<li>A <code>Derived</code> object contains a <code>Base</code> subobject</li>
<li>The base part always exists</li>
<li>You are only <em>restricting access</em>, not assuming more</li>
</ul>
<h4 id="2ï¸âƒ£-What-Is-Downcasting">2ï¸âƒ£ What Is Downcasting?</h4>
<h5 id="Definition-2">Definition</h5>
<p>Downcasting is converting a base-class pointer or reference<br>
to a derived-class pointer or reference.</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Base â†’ Derived</span><br></pre></td></tr></tbody></table></figure>
<h5 id="Example-Unsafe">Example (Unsafe)</h5>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(b);  <span class="comment">// downcasting</span></span><br></pre></td></tr></tbody></table></figure>
<p>âŒ Unsafe<br>
âŒ No runtime check<br>
âŒ Undefined behavior if object is not actually <code>Derived</code></p>
<h3 id="C-Explicit-Type-Casting">C++ Explicit Type Casting</h3>
<p><strong>Keywords:</strong> <code>static_cast</code>, <code>dynamic_cast</code>, <code>reinterpret_cast</code>, <code>const_cast</code></p>
<hr>
<h4 id="1-static-cast">1. <code>static_cast</code></h4>
<p><code>static_cast</code> does not perform runtime type checking to guarantee the safety of the conversion.</p>
<ul>
<li>
<p><strong>Upcasting</strong><br>
(converting a derived-class pointer or reference to a base-class representation)<br>
is safe.</p>
</li>
<li>
<p><strong>Downcasting</strong><br>
(converting a base-class pointer or reference to a derived-class representation)<br>
is unsafe, because there is no dynamic type checking.</p>
</li>
</ul>
<p><strong>Usage</strong></p>
<ol>
<li>Used for conversions between basic data types, such as converting <code>int</code> to <code>char</code>.</li>
<li>Used to convert any expression to type <code>void</code>.</li>
</ol>
<h3 id="C-Virtual-Functions">C++ Virtual Functions</h3>
<p><strong>1. Introduction</strong></p>
<p>In C++, a virtual function is a member function of a class that is declared using the keyword <code>virtual</code> and is intended to be overridden in a derived class.</p>
<p>Virtual functions enable runtime polymorphism, which means the function that is executed is determined at runtime based on the actual type of the object, not the type of the pointer or reference used to access it.</p>
<p><strong>1. Motivation</strong></p>
<p>By default, C++ uses compile-time dispatch, where function calls are resolved based on the static type.</p>
<p>This behavior prevents correct polymorphic behavior when using base-class pointers or references.</p>
<p>Virtual functions solve this problem by deferring function selection until runtime.</p>
<p><strong>1. Basic Example</strong></p>
<p><strong>3.1 Without Virtual Function (Compile-Time Dispatch)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">b-&gt;<span class="built_in">speak</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Base speaking</span><br></pre></td></tr></tbody></table></figure>
<p><strong>3.2 With Virtual Function (Runtime Dispatch)</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Base speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>{</span><br><span class="line">        cout &lt;&lt; <span class="string">"Derived speaking"</span> &lt;&lt; endl;</span><br><span class="line">    }</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">b-&gt;<span class="built_in">speak</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">Derived speaking</span><br></pre></td></tr></tbody></table></figure>
<h3 id="2-dynamic-cast">2. <code>dynamic_cast</code></h3>
<p>When performing downcasting, <code>dynamic_cast</code> provides runtime type checking<br>
(the required information comes from polymorphic types), making it safer than <code>static_cast</code>.</p>
<p>After casting, the result must be a class pointer, reference, or <code>void*</code>.</p>
<p>The base class must have at least one virtual function, and cross-casting is supported.</p>
<p><code>dynamic_cast</code> can only be used for explicit type conversions within inheritance hierarchies that contain virtual functions.</p>
<ul>
<li>For <strong>pointers</strong>: if the cast fails, it returns <code>nullptr</code></li>
<li>For <strong>references</strong>: if the cast fails, an exception is thrown</li>
</ul>
<p><strong>1ï¸âƒ£ Pointer <code>dynamic_cast</code> â†’ returns <code>nullptr</code></strong></p>
<p><strong>When this happens</strong></p>
<p>A pointer <code>dynamic_cast</code> fails when the actual object is <strong>NOT</strong> of the target type.</p>
<p><strong>Conditions</strong></p>
<p>This happens when all of the following are true:</p>
<ol>
<li>You are casting a <strong>pointer</strong></li>
<li>The base class is <strong>polymorphic</strong> (has a virtual function)</li>
<li>The runtime object type does <strong>NOT</strong> match the target type</li>
</ol>
<p><strong>Example</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> {</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() {}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base {};</span><br><span class="line"></span><br><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();   <span class="comment">// actual object is Base</span></span><br><span class="line"></span><br><span class="line">Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(b);</span><br></pre></td></tr></tbody></table></figure>
<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">d == nullptr   // true</span><br></pre></td></tr></tbody></table></figure>
<p><strong>2ï¸âƒ£ Reference dynamic_cast â†’ throws std::bad_cast</strong></p>
<figure class="highlight cpp"><table><tbody><tr><td class="code"><pre><span class="line">Base* b = <span class="keyword">new</span> <span class="built_in">Base</span>();   <span class="comment">// actual object is Base</span></span><br><span class="line"></span><br><span class="line">Derived&amp; d = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*b);</span><br></pre></td></tr></tbody></table></figure>
<p>Output:</p>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">std::bad_cast is thrown</span><br></pre></td></tr></tbody></table></figure>
<h3 id="3-reinterpret-cast">3. <code>reinterpret_cast</code></h3>
<p>It can convert an integer to a pointer, and can also convert a pointer to an integer.</p>
<p>It allows arbitrary, unchecked conversions between pointers and references.</p>
<p>Its platform portability is poor.</p>
<h3 id="4-const-cast">4. <code>const_cast</code></h3>
<p>It converts a const pointer to a non-const pointer while still pointing to the original object.</p>
<p>A const reference can be converted to a non-const reference while still referring to the original object.</p>
<p>It removes the <code>const</code> or <code>volatile</code> qualifiers from a type.</p>
<h2 id="C-Memory-Management">C++ Memory Management</h2>
<h3 id="Difference-Between-Stack-and-Heap">Difference Between Stack and Heap</h3>
<p>Both the stack and the heap are memory areas used to store program data.</p>
<p>The <strong>stack</strong> is a limited memory region used to store local variables, function call information, and similar data.</p>
<p>The <strong>heap</strong> is a dynamically allocated memory region used to store data that is allocated at runtime.</p>
<p>The lifetime of variables on the <strong>stack</strong> is the same as the execution duration of the function in which they are defined.</p>
<p>The lifetime of variables on the <strong>heap</strong> is explicitly controlled by the programmer and can be allocated (using <code>new</code> or <code>malloc</code>) and released (using <code>delete</code> or <code>free</code>).</p>
<p>Memory allocation and deallocation on the <strong>stack</strong> are automatic and fast.</p>
<p>Memory allocation and deallocation on the <strong>heap</strong> require manual operations and are relatively slower.</p>
<h1>C++ Memory Layout</h1>
<p>When a C++ program runs, memory is divided into several different regions, and each region is responsible for a different task.</p>
<hr>
<h3 id="Memory-Regions-Overview">Memory Regions Overview</h3>
<p><strong>High Address</strong></p>
<p><strong>Stack Area (stack)</strong><br>
<em>(Grows downward)</em></p>
<ul>
<li>Automatically allocated and released by the compiler</li>
<li>Stores: local variables, function parameters, return values</li>
</ul>
<hr>
<p><strong>Heap Area (heap)</strong><br>
<em>(Grows upward)</em></p>
<ul>
<li>Memory is allocated and released by the programmer</li>
<li>Allocation functions: <code>malloc()</code> and <code>free()</code></li>
</ul>
<hr>
<p><strong>Global (Static) Area</strong></p>
<ul>
<li>Uninitialized global/static area (<code>.bss</code>)</li>
<li>Initialized global/static area (<code>.data</code>)</li>
</ul>
<p><strong>Constant Area</strong></p>
<ul>
<li>Constant area (<code>.rodata</code>)</li>
<li>Stores constants such as string literals <code>"ABCD"</code></li>
</ul>
<p><strong>Code Area</strong></p>
<ul>
<li>Code area (<code>.text</code>)</li>
<li>Stores the programâ€™s executable code</li>
</ul>
<p><strong>Low Address</strong></p>
<hr>
<p><img src="image.png" alt="alt text"></p>
<p><strong>1. Stack</strong></p>
<p>The stack is used to store local variables, function parameters, and function call information.<br>
Function calls and returns are managed through the stack.</p>
<p><strong>2. Heap</strong></p>
<p>The heap is used to store dynamically allocated memory.<br>
Memory allocation and deallocation are manually controlled by the programmer.<br>
Heap memory is allocated and released using <code>new</code> and <code>delete</code>, or <code>malloc</code> and <code>free</code>.</p>
<p><strong>3. Global / Static Area</strong></p>
<p>The global area stores global variables and static variables.<br>
Their lifetime is the entire duration of program execution.<br>
Memory is allocated when the program starts and released when the program ends.</p>
<p><strong>4. Constant Area</strong></p>
<p>The constant area is also called the read-only area.<br>
It stores constant data, such as string literals.<br>
<strong>5. Code Area</strong></p>
<p>The code area stores the programâ€™s executable code.</p>
<h3 id="Memory-Leak-How-to-Avoid-It">Memory Leak? How to Avoid It?</h3>
<p><strong>1. What Is a Memory Leak?</strong></p>
<p>A <strong>memory leak</strong> refers to a situation where, due to negligence or programming errors, a program fails to release memory that is no longer needed.</p>
<p>A memory leak does not mean that memory physically disappears.<br>
Rather, after an application allocates a block of memory, due to design errors, it <strong>loses control of that memory</strong>, which results in wasted memory.</p>
<p>Memory leak detection can be performed using tools such as <strong>Valgrind</strong> and <strong>mtrace</strong>.</p>
<p><strong>2. Types of Memory Leaks</strong></p>
<p><strong>(1) Heap Memory Leak (Heap Leak)</strong></p>
<p>Heap memory refers to memory dynamically allocated during program execution using functions such as <code>malloc</code>, <code>realloc</code>, or <code>new</code>.</p>
<p>After use, this memory must be released using the corresponding <code>free</code> or <code>delete</code>.</p>
<p>If program design errors cause this memory not to be released, the memory will no longer be reused, resulting in a <strong>heap leak</strong>.</p>
<p><strong>(2) System Resource Leak (Resource Leak)</strong></p>
<p>This mainly refers to system-allocated resources such as <strong>bitmaps, handles, sockets</strong>, etc., that are not released using the corresponding release functions.</p>
<p>This leads to wasted system resources and, in severe cases, can cause <strong>performance degradation or system instability</strong>.</p>
<p><strong>(3) Base Class Destructor Not Declared as Virtual</strong></p>
<p>When a base-class pointer points to a derived-class object, if the base class destructor is not declared as <strong>virtual</strong>, the derived class destructor will not be called.</p>
<p>As a result, resources owned by the derived class are not correctly released, causing a <strong>memory leak</strong>.</p>
<p><strong>3. What Operations Can Cause Memory Leaks?</strong></p>
<ul>
<li>Changing a pointerâ€™s target without releasing dynamically allocated memory.</li>
</ul>
<p><strong>4. How to Prevent Memory Leaks?</strong></p>
<ul>
<li>Encapsulate memory allocation inside classes</li>
<li>Allocate memory in constructors and release memory in destructors</li>
<li>Use <strong>smart pointers</strong></li>
</ul>
<p><strong>5. What Smart Pointers Are Available?</strong></p>
<p>Smart pointers were introduced to solve problems such as memory leaks and multiple deletions caused by dynamic memory allocation.</p>
<p>They are provided in the C++11 standard <code>&lt;memory&gt;</code> header.</p>
<p>They include:</p>
<ul>
<li>Shared pointer</li>
<li>Unique pointer</li>
<li>Weak pointer</li>
</ul>
<p><strong>6. Should Constructors and Destructors Be Virtual? Why?</strong></p>
<p><strong>(1) Destructor</strong></p>
<p>Destructors <strong>should be virtual</strong>.</p>
<p>When a derived-class object owns dynamically allocated memory, if the destructor is not virtual, dynamic binding will not occur.</p>
<p>Only the base-class destructor will be called, preventing the derived-class resources from being released and causing a <strong>memory leak</strong>.</p>
<p><strong>(2) Constructor</strong></p>
<p>Constructors <strong>should not be virtual</strong> and do not need to be virtual.</p>
<p>Virtual function calls rely on partial object information and allow behavior to be determined without knowing the exact object type.</p>
<p>However, when creating an object, the complete type must be known.</p>
<p>In particular, you must know the <strong>exact type</strong> of the object you want to create.</p>
<p>Therefore, constructors should not be declared as virtual.</p>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>Tree</title>
    <url>/2025/08/29/DataStructures-Algorithms/Tree/</url>
    <content><![CDATA[<h1>Log-Structured Merge Tree (LSM-tree)</h1>
<h2 id="Definition-Easy">Definition (Easy)</h2>
<p>An <strong>LSM-tree</strong> is a way to store <strong>keyâ€“value data</strong> that makes <strong>writing very fast</strong> by:</p>
<ul>
<li><strong>First writing</strong> new data into memory (a small sorted table)</li>
<li><strong>Later saving</strong> it to disk as sorted files (<strong>SSTables</strong>)</li>
<li><strong>Merging</strong> old files in the background to keep them organized</li>
</ul>
<h2 id="Function">Function</h2>
<h3 id="LSM-Tree-Overall-Storage-Flow">LSM-Tree Overall Storage Flow</h3>
<figure class="highlight text"><table><tbody><tr><td class="code"><pre><span class="line">             (new writes)</span><br><span class="line">                 â†“</span><br><span class="line">+---------------------------+</span><br><span class="line">|         MemTable          |  (in memory, e.g. skip list, sorted)</span><br><span class="line">+---------------------------+</span><br><span class="line">                 â”‚ flush (when full)</span><br><span class="line">                 â–¼</span><br><span class="line">+---------------------------+</span><br><span class="line">|   SSTable_1 (Level 0)     |  &lt;- small, sorted internally</span><br><span class="line">+---------------------------+</span><br><span class="line">+---------------------------+</span><br><span class="line">|   SSTable_2 (Level 0)     |  &lt;- small, sorted internally</span><br><span class="line">+---------------------------+</span><br><span class="line">          ... more L0 SSTs ...</span><br><span class="line">        (can have overlapping keys)</span><br><span class="line">                 â”‚</span><br><span class="line">                 â”‚ compaction merges &amp; sorts</span><br><span class="line">                 â–¼</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|           Level 1 SSTables (bigger)                 |</span><br><span class="line">|  - Disjoint key ranges (no overlap between files)   |</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">                 â”‚</span><br><span class="line">                 â–¼</span><br><span class="line">+-----------------------------------------------------+</span><br><span class="line">|           Level 2, Level 3 ...                      |</span><br><span class="line">|   - Much larger SSTables                            |</span><br><span class="line">|   - Still disjoint key ranges                       |</span><br><span class="line">+-----------------------------------------------------+</span><br></pre></td></tr></tbody></table></figure>
]]></content>
      <categories>
        <category>DataStructure-Algorithms</category>
      </categories>
      <tags>
        <tag>DataStructure Algorithms</tag>
      </tags>
  </entry>
</search>
